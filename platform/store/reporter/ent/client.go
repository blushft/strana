// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"github.com/blushft/strana/platform/store/reporter/ent/migrate"
	"github.com/google/uuid"

	"github.com/blushft/strana/platform/store/reporter/ent/action"
	"github.com/blushft/strana/platform/store/reporter/ent/app"
	"github.com/blushft/strana/platform/store/reporter/ent/appstat"
	"github.com/blushft/strana/platform/store/reporter/ent/device"
	"github.com/blushft/strana/platform/store/reporter/ent/hostname"
	"github.com/blushft/strana/platform/store/reporter/ent/pagestat"
	"github.com/blushft/strana/platform/store/reporter/ent/pageview"
	"github.com/blushft/strana/platform/store/reporter/ent/pathname"
	"github.com/blushft/strana/platform/store/reporter/ent/screen"
	"github.com/blushft/strana/platform/store/reporter/ent/session"
	"github.com/blushft/strana/platform/store/reporter/ent/user"

	"github.com/facebook/ent/dialect"
	"github.com/facebook/ent/dialect/sql"
	"github.com/facebook/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Action is the client for interacting with the Action builders.
	Action *ActionClient
	// App is the client for interacting with the App builders.
	App *AppClient
	// AppStat is the client for interacting with the AppStat builders.
	AppStat *AppStatClient
	// Device is the client for interacting with the Device builders.
	Device *DeviceClient
	// Hostname is the client for interacting with the Hostname builders.
	Hostname *HostnameClient
	// PageStat is the client for interacting with the PageStat builders.
	PageStat *PageStatClient
	// PageView is the client for interacting with the PageView builders.
	PageView *PageViewClient
	// Pathname is the client for interacting with the Pathname builders.
	Pathname *PathnameClient
	// Screen is the client for interacting with the Screen builders.
	Screen *ScreenClient
	// Session is the client for interacting with the Session builders.
	Session *SessionClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Action = NewActionClient(c.config)
	c.App = NewAppClient(c.config)
	c.AppStat = NewAppStatClient(c.config)
	c.Device = NewDeviceClient(c.config)
	c.Hostname = NewHostnameClient(c.config)
	c.PageStat = NewPageStatClient(c.config)
	c.PageView = NewPageViewClient(c.config)
	c.Pathname = NewPathnameClient(c.config)
	c.Screen = NewScreenClient(c.config)
	c.Session = NewSessionClient(c.config)
	c.User = NewUserClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: tx, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		ctx:      ctx,
		config:   cfg,
		Action:   NewActionClient(cfg),
		App:      NewAppClient(cfg),
		AppStat:  NewAppStatClient(cfg),
		Device:   NewDeviceClient(cfg),
		Hostname: NewHostnameClient(cfg),
		PageStat: NewPageStatClient(cfg),
		PageView: NewPageViewClient(cfg),
		Pathname: NewPathnameClient(cfg),
		Screen:   NewScreenClient(cfg),
		Session:  NewSessionClient(cfg),
		User:     NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(*sql.Driver).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: &txDriver{tx: tx, drv: c.driver}, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		config:   cfg,
		Action:   NewActionClient(cfg),
		App:      NewAppClient(cfg),
		AppStat:  NewAppStatClient(cfg),
		Device:   NewDeviceClient(cfg),
		Hostname: NewHostnameClient(cfg),
		PageStat: NewPageStatClient(cfg),
		PageView: NewPageViewClient(cfg),
		Pathname: NewPathnameClient(cfg),
		Screen:   NewScreenClient(cfg),
		Session:  NewSessionClient(cfg),
		User:     NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Action.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := config{driver: dialect.Debug(c.driver, c.log), log: c.log, debug: true, hooks: c.hooks}
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Action.Use(hooks...)
	c.App.Use(hooks...)
	c.AppStat.Use(hooks...)
	c.Device.Use(hooks...)
	c.Hostname.Use(hooks...)
	c.PageStat.Use(hooks...)
	c.PageView.Use(hooks...)
	c.Pathname.Use(hooks...)
	c.Screen.Use(hooks...)
	c.Session.Use(hooks...)
	c.User.Use(hooks...)
}

// ActionClient is a client for the Action schema.
type ActionClient struct {
	config
}

// NewActionClient returns a client for the Action from the given config.
func NewActionClient(c config) *ActionClient {
	return &ActionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `action.Hooks(f(g(h())))`.
func (c *ActionClient) Use(hooks ...Hook) {
	c.hooks.Action = append(c.hooks.Action, hooks...)
}

// Create returns a create builder for Action.
func (c *ActionClient) Create() *ActionCreate {
	mutation := newActionMutation(c.config, OpCreate)
	return &ActionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Action entities.
func (c *ActionClient) CreateBulk(builders ...*ActionCreate) *ActionCreateBulk {
	return &ActionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Action.
func (c *ActionClient) Update() *ActionUpdate {
	mutation := newActionMutation(c.config, OpUpdate)
	return &ActionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ActionClient) UpdateOne(a *Action) *ActionUpdateOne {
	mutation := newActionMutation(c.config, OpUpdateOne, withAction(a))
	return &ActionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ActionClient) UpdateOneID(id int) *ActionUpdateOne {
	mutation := newActionMutation(c.config, OpUpdateOne, withActionID(id))
	return &ActionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Action.
func (c *ActionClient) Delete() *ActionDelete {
	mutation := newActionMutation(c.config, OpDelete)
	return &ActionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ActionClient) DeleteOne(a *Action) *ActionDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ActionClient) DeleteOneID(id int) *ActionDeleteOne {
	builder := c.Delete().Where(action.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ActionDeleteOne{builder}
}

// Query returns a query builder for Action.
func (c *ActionClient) Query() *ActionQuery {
	return &ActionQuery{config: c.config}
}

// Get returns a Action entity by its id.
func (c *ActionClient) Get(ctx context.Context, id int) (*Action, error) {
	return c.Query().Where(action.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ActionClient) GetX(ctx context.Context, id int) *Action {
	a, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return a
}

// Hooks returns the client hooks.
func (c *ActionClient) Hooks() []Hook {
	return c.hooks.Action
}

// AppClient is a client for the App schema.
type AppClient struct {
	config
}

// NewAppClient returns a client for the App from the given config.
func NewAppClient(c config) *AppClient {
	return &AppClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `app.Hooks(f(g(h())))`.
func (c *AppClient) Use(hooks ...Hook) {
	c.hooks.App = append(c.hooks.App, hooks...)
}

// Create returns a create builder for App.
func (c *AppClient) Create() *AppCreate {
	mutation := newAppMutation(c.config, OpCreate)
	return &AppCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of App entities.
func (c *AppClient) CreateBulk(builders ...*AppCreate) *AppCreateBulk {
	return &AppCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for App.
func (c *AppClient) Update() *AppUpdate {
	mutation := newAppMutation(c.config, OpUpdate)
	return &AppUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppClient) UpdateOne(a *App) *AppUpdateOne {
	mutation := newAppMutation(c.config, OpUpdateOne, withApp(a))
	return &AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppClient) UpdateOneID(id int) *AppUpdateOne {
	mutation := newAppMutation(c.config, OpUpdateOne, withAppID(id))
	return &AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for App.
func (c *AppClient) Delete() *AppDelete {
	mutation := newAppMutation(c.config, OpDelete)
	return &AppDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AppClient) DeleteOne(a *App) *AppDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AppClient) DeleteOneID(id int) *AppDeleteOne {
	builder := c.Delete().Where(app.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppDeleteOne{builder}
}

// Query returns a query builder for App.
func (c *AppClient) Query() *AppQuery {
	return &AppQuery{config: c.config}
}

// Get returns a App entity by its id.
func (c *AppClient) Get(ctx context.Context, id int) (*App, error) {
	return c.Query().Where(app.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppClient) GetX(ctx context.Context, id int) *App {
	a, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return a
}

// QuerySessions queries the sessions edge of a App.
func (c *AppClient) QuerySessions(a *App) *SessionQuery {
	query := &SessionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(session.Table, session.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, app.SessionsTable, app.SessionsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPageviews queries the pageviews edge of a App.
func (c *AppClient) QueryPageviews(a *App) *PageViewQuery {
	query := &PageViewQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(pageview.Table, pageview.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, app.PageviewsTable, app.PageviewsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStats queries the stats edge of a App.
func (c *AppClient) QueryStats(a *App) *AppStatQuery {
	query := &AppStatQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(appstat.Table, appstat.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, app.StatsTable, app.StatsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPageStats queries the page_stats edge of a App.
func (c *AppClient) QueryPageStats(a *App) *PageStatQuery {
	query := &PageStatQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(pagestat.Table, pagestat.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, app.PageStatsTable, app.PageStatsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AppClient) Hooks() []Hook {
	return c.hooks.App
}

// AppStatClient is a client for the AppStat schema.
type AppStatClient struct {
	config
}

// NewAppStatClient returns a client for the AppStat from the given config.
func NewAppStatClient(c config) *AppStatClient {
	return &AppStatClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appstat.Hooks(f(g(h())))`.
func (c *AppStatClient) Use(hooks ...Hook) {
	c.hooks.AppStat = append(c.hooks.AppStat, hooks...)
}

// Create returns a create builder for AppStat.
func (c *AppStatClient) Create() *AppStatCreate {
	mutation := newAppStatMutation(c.config, OpCreate)
	return &AppStatCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of AppStat entities.
func (c *AppStatClient) CreateBulk(builders ...*AppStatCreate) *AppStatCreateBulk {
	return &AppStatCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppStat.
func (c *AppStatClient) Update() *AppStatUpdate {
	mutation := newAppStatMutation(c.config, OpUpdate)
	return &AppStatUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppStatClient) UpdateOne(as *AppStat) *AppStatUpdateOne {
	mutation := newAppStatMutation(c.config, OpUpdateOne, withAppStat(as))
	return &AppStatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppStatClient) UpdateOneID(id int) *AppStatUpdateOne {
	mutation := newAppStatMutation(c.config, OpUpdateOne, withAppStatID(id))
	return &AppStatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppStat.
func (c *AppStatClient) Delete() *AppStatDelete {
	mutation := newAppStatMutation(c.config, OpDelete)
	return &AppStatDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AppStatClient) DeleteOne(as *AppStat) *AppStatDeleteOne {
	return c.DeleteOneID(as.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AppStatClient) DeleteOneID(id int) *AppStatDeleteOne {
	builder := c.Delete().Where(appstat.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppStatDeleteOne{builder}
}

// Query returns a query builder for AppStat.
func (c *AppStatClient) Query() *AppStatQuery {
	return &AppStatQuery{config: c.config}
}

// Get returns a AppStat entity by its id.
func (c *AppStatClient) Get(ctx context.Context, id int) (*AppStat, error) {
	return c.Query().Where(appstat.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppStatClient) GetX(ctx context.Context, id int) *AppStat {
	as, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return as
}

// QueryApp queries the app edge of a AppStat.
func (c *AppStatClient) QueryApp(as *AppStat) *AppQuery {
	query := &AppQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := as.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(appstat.Table, appstat.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, appstat.AppTable, appstat.AppColumn),
		)
		fromV = sqlgraph.Neighbors(as.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AppStatClient) Hooks() []Hook {
	return c.hooks.AppStat
}

// DeviceClient is a client for the Device schema.
type DeviceClient struct {
	config
}

// NewDeviceClient returns a client for the Device from the given config.
func NewDeviceClient(c config) *DeviceClient {
	return &DeviceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `device.Hooks(f(g(h())))`.
func (c *DeviceClient) Use(hooks ...Hook) {
	c.hooks.Device = append(c.hooks.Device, hooks...)
}

// Create returns a create builder for Device.
func (c *DeviceClient) Create() *DeviceCreate {
	mutation := newDeviceMutation(c.config, OpCreate)
	return &DeviceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Device entities.
func (c *DeviceClient) CreateBulk(builders ...*DeviceCreate) *DeviceCreateBulk {
	return &DeviceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Device.
func (c *DeviceClient) Update() *DeviceUpdate {
	mutation := newDeviceMutation(c.config, OpUpdate)
	return &DeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeviceClient) UpdateOne(d *Device) *DeviceUpdateOne {
	mutation := newDeviceMutation(c.config, OpUpdateOne, withDevice(d))
	return &DeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DeviceClient) UpdateOneID(id string) *DeviceUpdateOne {
	mutation := newDeviceMutation(c.config, OpUpdateOne, withDeviceID(id))
	return &DeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Device.
func (c *DeviceClient) Delete() *DeviceDelete {
	mutation := newDeviceMutation(c.config, OpDelete)
	return &DeviceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *DeviceClient) DeleteOne(d *Device) *DeviceDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *DeviceClient) DeleteOneID(id string) *DeviceDeleteOne {
	builder := c.Delete().Where(device.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeviceDeleteOne{builder}
}

// Query returns a query builder for Device.
func (c *DeviceClient) Query() *DeviceQuery {
	return &DeviceQuery{config: c.config}
}

// Get returns a Device entity by its id.
func (c *DeviceClient) Get(ctx context.Context, id string) (*Device, error) {
	return c.Query().Where(device.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeviceClient) GetX(ctx context.Context, id string) *Device {
	d, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return d
}

// QuerySessions queries the sessions edge of a Device.
func (c *DeviceClient) QuerySessions(d *Device) *SessionQuery {
	query := &SessionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(device.Table, device.FieldID, id),
			sqlgraph.To(session.Table, session.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, device.SessionsTable, device.SessionsColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DeviceClient) Hooks() []Hook {
	return c.hooks.Device
}

// HostnameClient is a client for the Hostname schema.
type HostnameClient struct {
	config
}

// NewHostnameClient returns a client for the Hostname from the given config.
func NewHostnameClient(c config) *HostnameClient {
	return &HostnameClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hostname.Hooks(f(g(h())))`.
func (c *HostnameClient) Use(hooks ...Hook) {
	c.hooks.Hostname = append(c.hooks.Hostname, hooks...)
}

// Create returns a create builder for Hostname.
func (c *HostnameClient) Create() *HostnameCreate {
	mutation := newHostnameMutation(c.config, OpCreate)
	return &HostnameCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Hostname entities.
func (c *HostnameClient) CreateBulk(builders ...*HostnameCreate) *HostnameCreateBulk {
	return &HostnameCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Hostname.
func (c *HostnameClient) Update() *HostnameUpdate {
	mutation := newHostnameMutation(c.config, OpUpdate)
	return &HostnameUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HostnameClient) UpdateOne(h *Hostname) *HostnameUpdateOne {
	mutation := newHostnameMutation(c.config, OpUpdateOne, withHostname(h))
	return &HostnameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HostnameClient) UpdateOneID(id int) *HostnameUpdateOne {
	mutation := newHostnameMutation(c.config, OpUpdateOne, withHostnameID(id))
	return &HostnameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Hostname.
func (c *HostnameClient) Delete() *HostnameDelete {
	mutation := newHostnameMutation(c.config, OpDelete)
	return &HostnameDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *HostnameClient) DeleteOne(h *Hostname) *HostnameDeleteOne {
	return c.DeleteOneID(h.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *HostnameClient) DeleteOneID(id int) *HostnameDeleteOne {
	builder := c.Delete().Where(hostname.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HostnameDeleteOne{builder}
}

// Query returns a query builder for Hostname.
func (c *HostnameClient) Query() *HostnameQuery {
	return &HostnameQuery{config: c.config}
}

// Get returns a Hostname entity by its id.
func (c *HostnameClient) Get(ctx context.Context, id int) (*Hostname, error) {
	return c.Query().Where(hostname.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HostnameClient) GetX(ctx context.Context, id int) *Hostname {
	h, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return h
}

// QueryPageStats queries the page_stats edge of a Hostname.
func (c *HostnameClient) QueryPageStats(h *Hostname) *PageStatQuery {
	query := &PageStatQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hostname.Table, hostname.FieldID, id),
			sqlgraph.To(pagestat.Table, pagestat.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, hostname.PageStatsTable, hostname.PageStatsColumn),
		)
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HostnameClient) Hooks() []Hook {
	return c.hooks.Hostname
}

// PageStatClient is a client for the PageStat schema.
type PageStatClient struct {
	config
}

// NewPageStatClient returns a client for the PageStat from the given config.
func NewPageStatClient(c config) *PageStatClient {
	return &PageStatClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `pagestat.Hooks(f(g(h())))`.
func (c *PageStatClient) Use(hooks ...Hook) {
	c.hooks.PageStat = append(c.hooks.PageStat, hooks...)
}

// Create returns a create builder for PageStat.
func (c *PageStatClient) Create() *PageStatCreate {
	mutation := newPageStatMutation(c.config, OpCreate)
	return &PageStatCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of PageStat entities.
func (c *PageStatClient) CreateBulk(builders ...*PageStatCreate) *PageStatCreateBulk {
	return &PageStatCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PageStat.
func (c *PageStatClient) Update() *PageStatUpdate {
	mutation := newPageStatMutation(c.config, OpUpdate)
	return &PageStatUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PageStatClient) UpdateOne(ps *PageStat) *PageStatUpdateOne {
	mutation := newPageStatMutation(c.config, OpUpdateOne, withPageStat(ps))
	return &PageStatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PageStatClient) UpdateOneID(id int) *PageStatUpdateOne {
	mutation := newPageStatMutation(c.config, OpUpdateOne, withPageStatID(id))
	return &PageStatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PageStat.
func (c *PageStatClient) Delete() *PageStatDelete {
	mutation := newPageStatMutation(c.config, OpDelete)
	return &PageStatDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *PageStatClient) DeleteOne(ps *PageStat) *PageStatDeleteOne {
	return c.DeleteOneID(ps.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *PageStatClient) DeleteOneID(id int) *PageStatDeleteOne {
	builder := c.Delete().Where(pagestat.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PageStatDeleteOne{builder}
}

// Query returns a query builder for PageStat.
func (c *PageStatClient) Query() *PageStatQuery {
	return &PageStatQuery{config: c.config}
}

// Get returns a PageStat entity by its id.
func (c *PageStatClient) Get(ctx context.Context, id int) (*PageStat, error) {
	return c.Query().Where(pagestat.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PageStatClient) GetX(ctx context.Context, id int) *PageStat {
	ps, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return ps
}

// QueryApp queries the app edge of a PageStat.
func (c *PageStatClient) QueryApp(ps *PageStat) *AppQuery {
	query := &AppQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pagestat.Table, pagestat.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, pagestat.AppTable, pagestat.AppColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHostname queries the hostname edge of a PageStat.
func (c *PageStatClient) QueryHostname(ps *PageStat) *HostnameQuery {
	query := &HostnameQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pagestat.Table, pagestat.FieldID, id),
			sqlgraph.To(hostname.Table, hostname.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, pagestat.HostnameTable, pagestat.HostnameColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPathname queries the pathname edge of a PageStat.
func (c *PageStatClient) QueryPathname(ps *PageStat) *PathnameQuery {
	query := &PathnameQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pagestat.Table, pagestat.FieldID, id),
			sqlgraph.To(pathname.Table, pathname.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, pagestat.PathnameTable, pagestat.PathnameColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PageStatClient) Hooks() []Hook {
	return c.hooks.PageStat
}

// PageViewClient is a client for the PageView schema.
type PageViewClient struct {
	config
}

// NewPageViewClient returns a client for the PageView from the given config.
func NewPageViewClient(c config) *PageViewClient {
	return &PageViewClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `pageview.Hooks(f(g(h())))`.
func (c *PageViewClient) Use(hooks ...Hook) {
	c.hooks.PageView = append(c.hooks.PageView, hooks...)
}

// Create returns a create builder for PageView.
func (c *PageViewClient) Create() *PageViewCreate {
	mutation := newPageViewMutation(c.config, OpCreate)
	return &PageViewCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of PageView entities.
func (c *PageViewClient) CreateBulk(builders ...*PageViewCreate) *PageViewCreateBulk {
	return &PageViewCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PageView.
func (c *PageViewClient) Update() *PageViewUpdate {
	mutation := newPageViewMutation(c.config, OpUpdate)
	return &PageViewUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PageViewClient) UpdateOne(pv *PageView) *PageViewUpdateOne {
	mutation := newPageViewMutation(c.config, OpUpdateOne, withPageView(pv))
	return &PageViewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PageViewClient) UpdateOneID(id uuid.UUID) *PageViewUpdateOne {
	mutation := newPageViewMutation(c.config, OpUpdateOne, withPageViewID(id))
	return &PageViewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PageView.
func (c *PageViewClient) Delete() *PageViewDelete {
	mutation := newPageViewMutation(c.config, OpDelete)
	return &PageViewDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *PageViewClient) DeleteOne(pv *PageView) *PageViewDeleteOne {
	return c.DeleteOneID(pv.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *PageViewClient) DeleteOneID(id uuid.UUID) *PageViewDeleteOne {
	builder := c.Delete().Where(pageview.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PageViewDeleteOne{builder}
}

// Query returns a query builder for PageView.
func (c *PageViewClient) Query() *PageViewQuery {
	return &PageViewQuery{config: c.config}
}

// Get returns a PageView entity by its id.
func (c *PageViewClient) Get(ctx context.Context, id uuid.UUID) (*PageView, error) {
	return c.Query().Where(pageview.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PageViewClient) GetX(ctx context.Context, id uuid.UUID) *PageView {
	pv, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return pv
}

// QueryApp queries the app edge of a PageView.
func (c *PageViewClient) QueryApp(pv *PageView) *AppQuery {
	query := &AppQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pageview.Table, pageview.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, pageview.AppTable, pageview.AppColumn),
		)
		fromV = sqlgraph.Neighbors(pv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySession queries the session edge of a PageView.
func (c *PageViewClient) QuerySession(pv *PageView) *SessionQuery {
	query := &SessionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pageview.Table, pageview.FieldID, id),
			sqlgraph.To(session.Table, session.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, pageview.SessionTable, pageview.SessionColumn),
		)
		fromV = sqlgraph.Neighbors(pv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a PageView.
func (c *PageViewClient) QueryUser(pv *PageView) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pageview.Table, pageview.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, pageview.UserTable, pageview.UserColumn),
		)
		fromV = sqlgraph.Neighbors(pv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PageViewClient) Hooks() []Hook {
	return c.hooks.PageView
}

// PathnameClient is a client for the Pathname schema.
type PathnameClient struct {
	config
}

// NewPathnameClient returns a client for the Pathname from the given config.
func NewPathnameClient(c config) *PathnameClient {
	return &PathnameClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `pathname.Hooks(f(g(h())))`.
func (c *PathnameClient) Use(hooks ...Hook) {
	c.hooks.Pathname = append(c.hooks.Pathname, hooks...)
}

// Create returns a create builder for Pathname.
func (c *PathnameClient) Create() *PathnameCreate {
	mutation := newPathnameMutation(c.config, OpCreate)
	return &PathnameCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Pathname entities.
func (c *PathnameClient) CreateBulk(builders ...*PathnameCreate) *PathnameCreateBulk {
	return &PathnameCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Pathname.
func (c *PathnameClient) Update() *PathnameUpdate {
	mutation := newPathnameMutation(c.config, OpUpdate)
	return &PathnameUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PathnameClient) UpdateOne(pa *Pathname) *PathnameUpdateOne {
	mutation := newPathnameMutation(c.config, OpUpdateOne, withPathname(pa))
	return &PathnameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PathnameClient) UpdateOneID(id int) *PathnameUpdateOne {
	mutation := newPathnameMutation(c.config, OpUpdateOne, withPathnameID(id))
	return &PathnameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Pathname.
func (c *PathnameClient) Delete() *PathnameDelete {
	mutation := newPathnameMutation(c.config, OpDelete)
	return &PathnameDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *PathnameClient) DeleteOne(pa *Pathname) *PathnameDeleteOne {
	return c.DeleteOneID(pa.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *PathnameClient) DeleteOneID(id int) *PathnameDeleteOne {
	builder := c.Delete().Where(pathname.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PathnameDeleteOne{builder}
}

// Query returns a query builder for Pathname.
func (c *PathnameClient) Query() *PathnameQuery {
	return &PathnameQuery{config: c.config}
}

// Get returns a Pathname entity by its id.
func (c *PathnameClient) Get(ctx context.Context, id int) (*Pathname, error) {
	return c.Query().Where(pathname.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PathnameClient) GetX(ctx context.Context, id int) *Pathname {
	pa, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return pa
}

// QueryPageStats queries the page_stats edge of a Pathname.
func (c *PathnameClient) QueryPageStats(pa *Pathname) *PageStatQuery {
	query := &PageStatQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pathname.Table, pathname.FieldID, id),
			sqlgraph.To(pagestat.Table, pagestat.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, pathname.PageStatsTable, pathname.PageStatsColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PathnameClient) Hooks() []Hook {
	return c.hooks.Pathname
}

// ScreenClient is a client for the Screen schema.
type ScreenClient struct {
	config
}

// NewScreenClient returns a client for the Screen from the given config.
func NewScreenClient(c config) *ScreenClient {
	return &ScreenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `screen.Hooks(f(g(h())))`.
func (c *ScreenClient) Use(hooks ...Hook) {
	c.hooks.Screen = append(c.hooks.Screen, hooks...)
}

// Create returns a create builder for Screen.
func (c *ScreenClient) Create() *ScreenCreate {
	mutation := newScreenMutation(c.config, OpCreate)
	return &ScreenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Screen entities.
func (c *ScreenClient) CreateBulk(builders ...*ScreenCreate) *ScreenCreateBulk {
	return &ScreenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Screen.
func (c *ScreenClient) Update() *ScreenUpdate {
	mutation := newScreenMutation(c.config, OpUpdate)
	return &ScreenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScreenClient) UpdateOne(s *Screen) *ScreenUpdateOne {
	mutation := newScreenMutation(c.config, OpUpdateOne, withScreen(s))
	return &ScreenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScreenClient) UpdateOneID(id int) *ScreenUpdateOne {
	mutation := newScreenMutation(c.config, OpUpdateOne, withScreenID(id))
	return &ScreenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Screen.
func (c *ScreenClient) Delete() *ScreenDelete {
	mutation := newScreenMutation(c.config, OpDelete)
	return &ScreenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ScreenClient) DeleteOne(s *Screen) *ScreenDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ScreenClient) DeleteOneID(id int) *ScreenDeleteOne {
	builder := c.Delete().Where(screen.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScreenDeleteOne{builder}
}

// Query returns a query builder for Screen.
func (c *ScreenClient) Query() *ScreenQuery {
	return &ScreenQuery{config: c.config}
}

// Get returns a Screen entity by its id.
func (c *ScreenClient) Get(ctx context.Context, id int) (*Screen, error) {
	return c.Query().Where(screen.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScreenClient) GetX(ctx context.Context, id int) *Screen {
	s, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return s
}

// Hooks returns the client hooks.
func (c *ScreenClient) Hooks() []Hook {
	return c.hooks.Screen
}

// SessionClient is a client for the Session schema.
type SessionClient struct {
	config
}

// NewSessionClient returns a client for the Session from the given config.
func NewSessionClient(c config) *SessionClient {
	return &SessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `session.Hooks(f(g(h())))`.
func (c *SessionClient) Use(hooks ...Hook) {
	c.hooks.Session = append(c.hooks.Session, hooks...)
}

// Create returns a create builder for Session.
func (c *SessionClient) Create() *SessionCreate {
	mutation := newSessionMutation(c.config, OpCreate)
	return &SessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Session entities.
func (c *SessionClient) CreateBulk(builders ...*SessionCreate) *SessionCreateBulk {
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Session.
func (c *SessionClient) Update() *SessionUpdate {
	mutation := newSessionMutation(c.config, OpUpdate)
	return &SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SessionClient) UpdateOne(s *Session) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSession(s))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SessionClient) UpdateOneID(id uuid.UUID) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSessionID(id))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Session.
func (c *SessionClient) Delete() *SessionDelete {
	mutation := newSessionMutation(c.config, OpDelete)
	return &SessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *SessionClient) DeleteOne(s *Session) *SessionDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *SessionClient) DeleteOneID(id uuid.UUID) *SessionDeleteOne {
	builder := c.Delete().Where(session.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SessionDeleteOne{builder}
}

// Query returns a query builder for Session.
func (c *SessionClient) Query() *SessionQuery {
	return &SessionQuery{config: c.config}
}

// Get returns a Session entity by its id.
func (c *SessionClient) Get(ctx context.Context, id uuid.UUID) (*Session, error) {
	return c.Query().Where(session.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SessionClient) GetX(ctx context.Context, id uuid.UUID) *Session {
	s, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return s
}

// QueryApp queries the app edge of a Session.
func (c *SessionClient) QueryApp(s *Session) *AppQuery {
	query := &AppQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(session.Table, session.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, session.AppTable, session.AppColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Session.
func (c *SessionClient) QueryUser(s *Session) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(session.Table, session.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, session.UserTable, session.UserColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDevice queries the device edge of a Session.
func (c *SessionClient) QueryDevice(s *Session) *DeviceQuery {
	query := &DeviceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(session.Table, session.FieldID, id),
			sqlgraph.To(device.Table, device.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, session.DeviceTable, session.DeviceColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPageviews queries the pageviews edge of a Session.
func (c *SessionClient) QueryPageviews(s *Session) *PageViewQuery {
	query := &PageViewQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(session.Table, session.FieldID, id),
			sqlgraph.To(pageview.Table, pageview.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, session.PageviewsTable, session.PageviewsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SessionClient) Hooks() []Hook {
	return c.hooks.Session
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Create returns a create builder for User.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id string) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *UserClient) DeleteOneID(id string) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{config: c.config}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id string) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id string) *User {
	u, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return u
}

// QuerySessions queries the sessions edge of a User.
func (c *UserClient) QuerySessions(u *User) *SessionQuery {
	query := &SessionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(session.Table, session.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.SessionsTable, user.SessionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}
