// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/blushft/strana/platform/store/reporter/ent/app"
	"github.com/blushft/strana/platform/store/reporter/ent/appstat"
	"github.com/blushft/strana/platform/store/reporter/ent/device"
	"github.com/blushft/strana/platform/store/reporter/ent/hostname"
	"github.com/blushft/strana/platform/store/reporter/ent/pagestat"
	"github.com/blushft/strana/platform/store/reporter/ent/pageview"
	"github.com/blushft/strana/platform/store/reporter/ent/pathname"
	"github.com/blushft/strana/platform/store/reporter/ent/session"
	"github.com/blushft/strana/platform/store/reporter/ent/user"
	"github.com/google/uuid"

	"github.com/facebook/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAction   = "Action"
	TypeApp      = "App"
	TypeAppStat  = "AppStat"
	TypeDevice   = "Device"
	TypeHostname = "Hostname"
	TypePageStat = "PageStat"
	TypePageView = "PageView"
	TypePathname = "Pathname"
	TypeScreen   = "Screen"
	TypeSession  = "Session"
	TypeUser     = "User"
)

// ActionMutation represents an operation that mutate the Actions
// nodes in the graph.
type ActionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Action, error)
}

var _ ent.Mutation = (*ActionMutation)(nil)

// actionOption allows to manage the mutation configuration using functional options.
type actionOption func(*ActionMutation)

// newActionMutation creates new mutation for $n.Name.
func newActionMutation(c config, op Op, opts ...actionOption) *ActionMutation {
	m := &ActionMutation{
		config:        c,
		op:            op,
		typ:           TypeAction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActionID sets the id field of the mutation.
func withActionID(id int) actionOption {
	return func(m *ActionMutation) {
		var (
			err   error
			once  sync.Once
			value *Action
		)
		m.oldValue = func(ctx context.Context) (*Action, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Action.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAction sets the old Action of the mutation.
func withAction(node *Action) actionOption {
	return func(m *ActionMutation) {
		m.oldValue = func(context.Context) (*Action, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ActionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// Op returns the operation name.
func (m *ActionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Action).
func (m *ActionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ActionMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ActionMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ActionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Action field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ActionMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Action field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ActionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ActionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ActionMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Action numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ActionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ActionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Action nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ActionMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Action field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ActionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ActionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ActionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ActionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ActionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ActionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ActionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Action unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ActionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Action edge %s", name)
}

// AppMutation represents an operation that mutate the Apps
// nodes in the graph.
type AppMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	tracking_id       *string
	clearedFields     map[string]struct{}
	sessions          map[uuid.UUID]struct{}
	removedsessions   map[uuid.UUID]struct{}
	pageviews         map[uuid.UUID]struct{}
	removedpageviews  map[uuid.UUID]struct{}
	stats             map[int]struct{}
	removedstats      map[int]struct{}
	page_stats        map[int]struct{}
	removedpage_stats map[int]struct{}
	done              bool
	oldValue          func(context.Context) (*App, error)
}

var _ ent.Mutation = (*AppMutation)(nil)

// appOption allows to manage the mutation configuration using functional options.
type appOption func(*AppMutation)

// newAppMutation creates new mutation for $n.Name.
func newAppMutation(c config, op Op, opts ...appOption) *AppMutation {
	m := &AppMutation{
		config:        c,
		op:            op,
		typ:           TypeApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppID sets the id field of the mutation.
func withAppID(id int) appOption {
	return func(m *AppMutation) {
		var (
			err   error
			once  sync.Once
			value *App
		)
		m.oldValue = func(ctx context.Context) (*App, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().App.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApp sets the old App of the mutation.
func withApp(node *App) appOption {
	return func(m *AppMutation) {
		m.oldValue = func(context.Context) (*App, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AppMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *AppMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *AppMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the App.
// If the App object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *AppMutation) ResetName() {
	m.name = nil
}

// SetTrackingID sets the tracking_id field.
func (m *AppMutation) SetTrackingID(s string) {
	m.tracking_id = &s
}

// TrackingID returns the tracking_id value in the mutation.
func (m *AppMutation) TrackingID() (r string, exists bool) {
	v := m.tracking_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTrackingID returns the old tracking_id value of the App.
// If the App object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppMutation) OldTrackingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTrackingID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTrackingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrackingID: %w", err)
	}
	return oldValue.TrackingID, nil
}

// ResetTrackingID reset all changes of the "tracking_id" field.
func (m *AppMutation) ResetTrackingID() {
	m.tracking_id = nil
}

// AddSessionIDs adds the sessions edge to Session by ids.
func (m *AppMutation) AddSessionIDs(ids ...uuid.UUID) {
	if m.sessions == nil {
		m.sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// RemoveSessionIDs removes the sessions edge to Session by ids.
func (m *AppMutation) RemoveSessionIDs(ids ...uuid.UUID) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed ids of sessions.
func (m *AppMutation) RemovedSessionsIDs() (ids []uuid.UUID) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the sessions ids in the mutation.
func (m *AppMutation) SessionsIDs() (ids []uuid.UUID) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions reset all changes of the "sessions" edge.
func (m *AppMutation) ResetSessions() {
	m.sessions = nil
	m.removedsessions = nil
}

// AddPageviewIDs adds the pageviews edge to PageView by ids.
func (m *AppMutation) AddPageviewIDs(ids ...uuid.UUID) {
	if m.pageviews == nil {
		m.pageviews = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.pageviews[ids[i]] = struct{}{}
	}
}

// RemovePageviewIDs removes the pageviews edge to PageView by ids.
func (m *AppMutation) RemovePageviewIDs(ids ...uuid.UUID) {
	if m.removedpageviews == nil {
		m.removedpageviews = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removedpageviews[ids[i]] = struct{}{}
	}
}

// RemovedPageviews returns the removed ids of pageviews.
func (m *AppMutation) RemovedPageviewsIDs() (ids []uuid.UUID) {
	for id := range m.removedpageviews {
		ids = append(ids, id)
	}
	return
}

// PageviewsIDs returns the pageviews ids in the mutation.
func (m *AppMutation) PageviewsIDs() (ids []uuid.UUID) {
	for id := range m.pageviews {
		ids = append(ids, id)
	}
	return
}

// ResetPageviews reset all changes of the "pageviews" edge.
func (m *AppMutation) ResetPageviews() {
	m.pageviews = nil
	m.removedpageviews = nil
}

// AddStatIDs adds the stats edge to AppStat by ids.
func (m *AppMutation) AddStatIDs(ids ...int) {
	if m.stats == nil {
		m.stats = make(map[int]struct{})
	}
	for i := range ids {
		m.stats[ids[i]] = struct{}{}
	}
}

// RemoveStatIDs removes the stats edge to AppStat by ids.
func (m *AppMutation) RemoveStatIDs(ids ...int) {
	if m.removedstats == nil {
		m.removedstats = make(map[int]struct{})
	}
	for i := range ids {
		m.removedstats[ids[i]] = struct{}{}
	}
}

// RemovedStats returns the removed ids of stats.
func (m *AppMutation) RemovedStatsIDs() (ids []int) {
	for id := range m.removedstats {
		ids = append(ids, id)
	}
	return
}

// StatsIDs returns the stats ids in the mutation.
func (m *AppMutation) StatsIDs() (ids []int) {
	for id := range m.stats {
		ids = append(ids, id)
	}
	return
}

// ResetStats reset all changes of the "stats" edge.
func (m *AppMutation) ResetStats() {
	m.stats = nil
	m.removedstats = nil
}

// AddPageStatIDs adds the page_stats edge to PageStat by ids.
func (m *AppMutation) AddPageStatIDs(ids ...int) {
	if m.page_stats == nil {
		m.page_stats = make(map[int]struct{})
	}
	for i := range ids {
		m.page_stats[ids[i]] = struct{}{}
	}
}

// RemovePageStatIDs removes the page_stats edge to PageStat by ids.
func (m *AppMutation) RemovePageStatIDs(ids ...int) {
	if m.removedpage_stats == nil {
		m.removedpage_stats = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpage_stats[ids[i]] = struct{}{}
	}
}

// RemovedPageStats returns the removed ids of page_stats.
func (m *AppMutation) RemovedPageStatsIDs() (ids []int) {
	for id := range m.removedpage_stats {
		ids = append(ids, id)
	}
	return
}

// PageStatsIDs returns the page_stats ids in the mutation.
func (m *AppMutation) PageStatsIDs() (ids []int) {
	for id := range m.page_stats {
		ids = append(ids, id)
	}
	return
}

// ResetPageStats reset all changes of the "page_stats" edge.
func (m *AppMutation) ResetPageStats() {
	m.page_stats = nil
	m.removedpage_stats = nil
}

// Op returns the operation name.
func (m *AppMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (App).
func (m *AppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AppMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, app.FieldName)
	}
	if m.tracking_id != nil {
		fields = append(fields, app.FieldTrackingID)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case app.FieldName:
		return m.Name()
	case app.FieldTrackingID:
		return m.TrackingID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case app.FieldName:
		return m.OldName(ctx)
	case app.FieldTrackingID:
		return m.OldTrackingID(ctx)
	}
	return nil, fmt.Errorf("unknown App field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case app.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case app.FieldTrackingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrackingID(v)
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AppMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AppMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AppMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown App numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AppMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMutation) ClearField(name string) error {
	return fmt.Errorf("unknown App nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AppMutation) ResetField(name string) error {
	switch name {
	case app.FieldName:
		m.ResetName()
		return nil
	case app.FieldTrackingID:
		m.ResetTrackingID()
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AppMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.sessions != nil {
		edges = append(edges, app.EdgeSessions)
	}
	if m.pageviews != nil {
		edges = append(edges, app.EdgePageviews)
	}
	if m.stats != nil {
		edges = append(edges, app.EdgeStats)
	}
	if m.page_stats != nil {
		edges = append(edges, app.EdgePageStats)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AppMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case app.EdgePageviews:
		ids := make([]ent.Value, 0, len(m.pageviews))
		for id := range m.pageviews {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeStats:
		ids := make([]ent.Value, 0, len(m.stats))
		for id := range m.stats {
			ids = append(ids, id)
		}
		return ids
	case app.EdgePageStats:
		ids := make([]ent.Value, 0, len(m.page_stats))
		for id := range m.page_stats {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedsessions != nil {
		edges = append(edges, app.EdgeSessions)
	}
	if m.removedpageviews != nil {
		edges = append(edges, app.EdgePageviews)
	}
	if m.removedstats != nil {
		edges = append(edges, app.EdgeStats)
	}
	if m.removedpage_stats != nil {
		edges = append(edges, app.EdgePageStats)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AppMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case app.EdgePageviews:
		ids := make([]ent.Value, 0, len(m.removedpageviews))
		for id := range m.removedpageviews {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeStats:
		ids := make([]ent.Value, 0, len(m.removedstats))
		for id := range m.removedstats {
			ids = append(ids, id)
		}
		return ids
	case app.EdgePageStats:
		ids := make([]ent.Value, 0, len(m.removedpage_stats))
		for id := range m.removedpage_stats {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AppMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AppMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown App unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AppMutation) ResetEdge(name string) error {
	switch name {
	case app.EdgeSessions:
		m.ResetSessions()
		return nil
	case app.EdgePageviews:
		m.ResetPageviews()
		return nil
	case app.EdgeStats:
		m.ResetStats()
		return nil
	case app.EdgePageStats:
		m.ResetPageStats()
		return nil
	}
	return fmt.Errorf("unknown App edge %s", name)
}

// AppStatMutation represents an operation that mutate the AppStats
// nodes in the graph.
type AppStatMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	pageviews          *int
	addpageviews       *int
	visitors           *int
	addvisitors        *int
	sessions           *int
	addsessions        *int
	bouce_rate         *float64
	addbouce_rate      *float64
	known_durations    *int
	addknown_durations *int
	avg_duration       *float64
	addavg_duration    *float64
	date               *time.Time
	clearedFields      map[string]struct{}
	app                *int
	clearedapp         bool
	done               bool
	oldValue           func(context.Context) (*AppStat, error)
}

var _ ent.Mutation = (*AppStatMutation)(nil)

// appstatOption allows to manage the mutation configuration using functional options.
type appstatOption func(*AppStatMutation)

// newAppStatMutation creates new mutation for $n.Name.
func newAppStatMutation(c config, op Op, opts ...appstatOption) *AppStatMutation {
	m := &AppStatMutation{
		config:        c,
		op:            op,
		typ:           TypeAppStat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppStatID sets the id field of the mutation.
func withAppStatID(id int) appstatOption {
	return func(m *AppStatMutation) {
		var (
			err   error
			once  sync.Once
			value *AppStat
		)
		m.oldValue = func(ctx context.Context) (*AppStat, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppStat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppStat sets the old AppStat of the mutation.
func withAppStat(node *AppStat) appstatOption {
	return func(m *AppStatMutation) {
		m.oldValue = func(context.Context) (*AppStat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppStatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppStatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AppStatMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPageviews sets the pageviews field.
func (m *AppStatMutation) SetPageviews(i int) {
	m.pageviews = &i
	m.addpageviews = nil
}

// Pageviews returns the pageviews value in the mutation.
func (m *AppStatMutation) Pageviews() (r int, exists bool) {
	v := m.pageviews
	if v == nil {
		return
	}
	return *v, true
}

// OldPageviews returns the old pageviews value of the AppStat.
// If the AppStat object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppStatMutation) OldPageviews(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPageviews is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPageviews requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPageviews: %w", err)
	}
	return oldValue.Pageviews, nil
}

// AddPageviews adds i to pageviews.
func (m *AppStatMutation) AddPageviews(i int) {
	if m.addpageviews != nil {
		*m.addpageviews += i
	} else {
		m.addpageviews = &i
	}
}

// AddedPageviews returns the value that was added to the pageviews field in this mutation.
func (m *AppStatMutation) AddedPageviews() (r int, exists bool) {
	v := m.addpageviews
	if v == nil {
		return
	}
	return *v, true
}

// ResetPageviews reset all changes of the "pageviews" field.
func (m *AppStatMutation) ResetPageviews() {
	m.pageviews = nil
	m.addpageviews = nil
}

// SetVisitors sets the visitors field.
func (m *AppStatMutation) SetVisitors(i int) {
	m.visitors = &i
	m.addvisitors = nil
}

// Visitors returns the visitors value in the mutation.
func (m *AppStatMutation) Visitors() (r int, exists bool) {
	v := m.visitors
	if v == nil {
		return
	}
	return *v, true
}

// OldVisitors returns the old visitors value of the AppStat.
// If the AppStat object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppStatMutation) OldVisitors(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVisitors is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVisitors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisitors: %w", err)
	}
	return oldValue.Visitors, nil
}

// AddVisitors adds i to visitors.
func (m *AppStatMutation) AddVisitors(i int) {
	if m.addvisitors != nil {
		*m.addvisitors += i
	} else {
		m.addvisitors = &i
	}
}

// AddedVisitors returns the value that was added to the visitors field in this mutation.
func (m *AppStatMutation) AddedVisitors() (r int, exists bool) {
	v := m.addvisitors
	if v == nil {
		return
	}
	return *v, true
}

// ResetVisitors reset all changes of the "visitors" field.
func (m *AppStatMutation) ResetVisitors() {
	m.visitors = nil
	m.addvisitors = nil
}

// SetSessions sets the sessions field.
func (m *AppStatMutation) SetSessions(i int) {
	m.sessions = &i
	m.addsessions = nil
}

// Sessions returns the sessions value in the mutation.
func (m *AppStatMutation) Sessions() (r int, exists bool) {
	v := m.sessions
	if v == nil {
		return
	}
	return *v, true
}

// OldSessions returns the old sessions value of the AppStat.
// If the AppStat object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppStatMutation) OldSessions(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSessions is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSessions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessions: %w", err)
	}
	return oldValue.Sessions, nil
}

// AddSessions adds i to sessions.
func (m *AppStatMutation) AddSessions(i int) {
	if m.addsessions != nil {
		*m.addsessions += i
	} else {
		m.addsessions = &i
	}
}

// AddedSessions returns the value that was added to the sessions field in this mutation.
func (m *AppStatMutation) AddedSessions() (r int, exists bool) {
	v := m.addsessions
	if v == nil {
		return
	}
	return *v, true
}

// ResetSessions reset all changes of the "sessions" field.
func (m *AppStatMutation) ResetSessions() {
	m.sessions = nil
	m.addsessions = nil
}

// SetBouceRate sets the bouce_rate field.
func (m *AppStatMutation) SetBouceRate(f float64) {
	m.bouce_rate = &f
	m.addbouce_rate = nil
}

// BouceRate returns the bouce_rate value in the mutation.
func (m *AppStatMutation) BouceRate() (r float64, exists bool) {
	v := m.bouce_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldBouceRate returns the old bouce_rate value of the AppStat.
// If the AppStat object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppStatMutation) OldBouceRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBouceRate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBouceRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBouceRate: %w", err)
	}
	return oldValue.BouceRate, nil
}

// AddBouceRate adds f to bouce_rate.
func (m *AppStatMutation) AddBouceRate(f float64) {
	if m.addbouce_rate != nil {
		*m.addbouce_rate += f
	} else {
		m.addbouce_rate = &f
	}
}

// AddedBouceRate returns the value that was added to the bouce_rate field in this mutation.
func (m *AppStatMutation) AddedBouceRate() (r float64, exists bool) {
	v := m.addbouce_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetBouceRate reset all changes of the "bouce_rate" field.
func (m *AppStatMutation) ResetBouceRate() {
	m.bouce_rate = nil
	m.addbouce_rate = nil
}

// SetKnownDurations sets the known_durations field.
func (m *AppStatMutation) SetKnownDurations(i int) {
	m.known_durations = &i
	m.addknown_durations = nil
}

// KnownDurations returns the known_durations value in the mutation.
func (m *AppStatMutation) KnownDurations() (r int, exists bool) {
	v := m.known_durations
	if v == nil {
		return
	}
	return *v, true
}

// OldKnownDurations returns the old known_durations value of the AppStat.
// If the AppStat object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppStatMutation) OldKnownDurations(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKnownDurations is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKnownDurations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKnownDurations: %w", err)
	}
	return oldValue.KnownDurations, nil
}

// AddKnownDurations adds i to known_durations.
func (m *AppStatMutation) AddKnownDurations(i int) {
	if m.addknown_durations != nil {
		*m.addknown_durations += i
	} else {
		m.addknown_durations = &i
	}
}

// AddedKnownDurations returns the value that was added to the known_durations field in this mutation.
func (m *AppStatMutation) AddedKnownDurations() (r int, exists bool) {
	v := m.addknown_durations
	if v == nil {
		return
	}
	return *v, true
}

// ResetKnownDurations reset all changes of the "known_durations" field.
func (m *AppStatMutation) ResetKnownDurations() {
	m.known_durations = nil
	m.addknown_durations = nil
}

// SetAvgDuration sets the avg_duration field.
func (m *AppStatMutation) SetAvgDuration(f float64) {
	m.avg_duration = &f
	m.addavg_duration = nil
}

// AvgDuration returns the avg_duration value in the mutation.
func (m *AppStatMutation) AvgDuration() (r float64, exists bool) {
	v := m.avg_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldAvgDuration returns the old avg_duration value of the AppStat.
// If the AppStat object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppStatMutation) OldAvgDuration(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAvgDuration is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAvgDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvgDuration: %w", err)
	}
	return oldValue.AvgDuration, nil
}

// AddAvgDuration adds f to avg_duration.
func (m *AppStatMutation) AddAvgDuration(f float64) {
	if m.addavg_duration != nil {
		*m.addavg_duration += f
	} else {
		m.addavg_duration = &f
	}
}

// AddedAvgDuration returns the value that was added to the avg_duration field in this mutation.
func (m *AppStatMutation) AddedAvgDuration() (r float64, exists bool) {
	v := m.addavg_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetAvgDuration reset all changes of the "avg_duration" field.
func (m *AppStatMutation) ResetAvgDuration() {
	m.avg_duration = nil
	m.addavg_duration = nil
}

// SetDate sets the date field.
func (m *AppStatMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the date value in the mutation.
func (m *AppStatMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old date value of the AppStat.
// If the AppStat object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppStatMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate reset all changes of the "date" field.
func (m *AppStatMutation) ResetDate() {
	m.date = nil
}

// SetAppID sets the app edge to App by id.
func (m *AppStatMutation) SetAppID(id int) {
	m.app = &id
}

// ClearApp clears the app edge to App.
func (m *AppStatMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared returns if the edge app was cleared.
func (m *AppStatMutation) AppCleared() bool {
	return m.clearedapp
}

// AppID returns the app id in the mutation.
func (m *AppStatMutation) AppID() (id int, exists bool) {
	if m.app != nil {
		return *m.app, true
	}
	return
}

// AppIDs returns the app ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppStatMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp reset all changes of the "app" edge.
func (m *AppStatMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// Op returns the operation name.
func (m *AppStatMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppStat).
func (m *AppStatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AppStatMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.pageviews != nil {
		fields = append(fields, appstat.FieldPageviews)
	}
	if m.visitors != nil {
		fields = append(fields, appstat.FieldVisitors)
	}
	if m.sessions != nil {
		fields = append(fields, appstat.FieldSessions)
	}
	if m.bouce_rate != nil {
		fields = append(fields, appstat.FieldBouceRate)
	}
	if m.known_durations != nil {
		fields = append(fields, appstat.FieldKnownDurations)
	}
	if m.avg_duration != nil {
		fields = append(fields, appstat.FieldAvgDuration)
	}
	if m.date != nil {
		fields = append(fields, appstat.FieldDate)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AppStatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appstat.FieldPageviews:
		return m.Pageviews()
	case appstat.FieldVisitors:
		return m.Visitors()
	case appstat.FieldSessions:
		return m.Sessions()
	case appstat.FieldBouceRate:
		return m.BouceRate()
	case appstat.FieldKnownDurations:
		return m.KnownDurations()
	case appstat.FieldAvgDuration:
		return m.AvgDuration()
	case appstat.FieldDate:
		return m.Date()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AppStatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appstat.FieldPageviews:
		return m.OldPageviews(ctx)
	case appstat.FieldVisitors:
		return m.OldVisitors(ctx)
	case appstat.FieldSessions:
		return m.OldSessions(ctx)
	case appstat.FieldBouceRate:
		return m.OldBouceRate(ctx)
	case appstat.FieldKnownDurations:
		return m.OldKnownDurations(ctx)
	case appstat.FieldAvgDuration:
		return m.OldAvgDuration(ctx)
	case appstat.FieldDate:
		return m.OldDate(ctx)
	}
	return nil, fmt.Errorf("unknown AppStat field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AppStatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appstat.FieldPageviews:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPageviews(v)
		return nil
	case appstat.FieldVisitors:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisitors(v)
		return nil
	case appstat.FieldSessions:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessions(v)
		return nil
	case appstat.FieldBouceRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBouceRate(v)
		return nil
	case appstat.FieldKnownDurations:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKnownDurations(v)
		return nil
	case appstat.FieldAvgDuration:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvgDuration(v)
		return nil
	case appstat.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	}
	return fmt.Errorf("unknown AppStat field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AppStatMutation) AddedFields() []string {
	var fields []string
	if m.addpageviews != nil {
		fields = append(fields, appstat.FieldPageviews)
	}
	if m.addvisitors != nil {
		fields = append(fields, appstat.FieldVisitors)
	}
	if m.addsessions != nil {
		fields = append(fields, appstat.FieldSessions)
	}
	if m.addbouce_rate != nil {
		fields = append(fields, appstat.FieldBouceRate)
	}
	if m.addknown_durations != nil {
		fields = append(fields, appstat.FieldKnownDurations)
	}
	if m.addavg_duration != nil {
		fields = append(fields, appstat.FieldAvgDuration)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AppStatMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appstat.FieldPageviews:
		return m.AddedPageviews()
	case appstat.FieldVisitors:
		return m.AddedVisitors()
	case appstat.FieldSessions:
		return m.AddedSessions()
	case appstat.FieldBouceRate:
		return m.AddedBouceRate()
	case appstat.FieldKnownDurations:
		return m.AddedKnownDurations()
	case appstat.FieldAvgDuration:
		return m.AddedAvgDuration()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AppStatMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appstat.FieldPageviews:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPageviews(v)
		return nil
	case appstat.FieldVisitors:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVisitors(v)
		return nil
	case appstat.FieldSessions:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSessions(v)
		return nil
	case appstat.FieldBouceRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBouceRate(v)
		return nil
	case appstat.FieldKnownDurations:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddKnownDurations(v)
		return nil
	case appstat.FieldAvgDuration:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvgDuration(v)
		return nil
	}
	return fmt.Errorf("unknown AppStat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AppStatMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AppStatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppStatMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppStat nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AppStatMutation) ResetField(name string) error {
	switch name {
	case appstat.FieldPageviews:
		m.ResetPageviews()
		return nil
	case appstat.FieldVisitors:
		m.ResetVisitors()
		return nil
	case appstat.FieldSessions:
		m.ResetSessions()
		return nil
	case appstat.FieldBouceRate:
		m.ResetBouceRate()
		return nil
	case appstat.FieldKnownDurations:
		m.ResetKnownDurations()
		return nil
	case appstat.FieldAvgDuration:
		m.ResetAvgDuration()
		return nil
	case appstat.FieldDate:
		m.ResetDate()
		return nil
	}
	return fmt.Errorf("unknown AppStat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AppStatMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.app != nil {
		edges = append(edges, appstat.EdgeApp)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AppStatMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appstat.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AppStatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AppStatMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AppStatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedapp {
		edges = append(edges, appstat.EdgeApp)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AppStatMutation) EdgeCleared(name string) bool {
	switch name {
	case appstat.EdgeApp:
		return m.clearedapp
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AppStatMutation) ClearEdge(name string) error {
	switch name {
	case appstat.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown AppStat unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AppStatMutation) ResetEdge(name string) error {
	switch name {
	case appstat.EdgeApp:
		m.ResetApp()
		return nil
	}
	return fmt.Errorf("unknown AppStat edge %s", name)
}

// DeviceMutation represents an operation that mutate the Devices
// nodes in the graph.
type DeviceMutation struct {
	config
	op              Op
	typ             string
	id              *string
	name            *string
	version         *string
	clearedFields   map[string]struct{}
	sessions        map[uuid.UUID]struct{}
	removedsessions map[uuid.UUID]struct{}
	done            bool
	oldValue        func(context.Context) (*Device, error)
}

var _ ent.Mutation = (*DeviceMutation)(nil)

// deviceOption allows to manage the mutation configuration using functional options.
type deviceOption func(*DeviceMutation)

// newDeviceMutation creates new mutation for $n.Name.
func newDeviceMutation(c config, op Op, opts ...deviceOption) *DeviceMutation {
	m := &DeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceID sets the id field of the mutation.
func withDeviceID(id string) deviceOption {
	return func(m *DeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *Device
		)
		m.oldValue = func(ctx context.Context) (*Device, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Device.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDevice sets the old Device of the mutation.
func withDevice(node *Device) deviceOption {
	return func(m *DeviceMutation) {
		m.oldValue = func(context.Context) (*Device, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Device creation.
func (m *DeviceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DeviceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *DeviceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *DeviceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Device.
// If the Device object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DeviceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *DeviceMutation) ResetName() {
	m.name = nil
}

// SetVersion sets the version field.
func (m *DeviceMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the version value in the mutation.
func (m *DeviceMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old version value of the Device.
// If the Device object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DeviceMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion reset all changes of the "version" field.
func (m *DeviceMutation) ResetVersion() {
	m.version = nil
}

// AddSessionIDs adds the sessions edge to Session by ids.
func (m *DeviceMutation) AddSessionIDs(ids ...uuid.UUID) {
	if m.sessions == nil {
		m.sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// RemoveSessionIDs removes the sessions edge to Session by ids.
func (m *DeviceMutation) RemoveSessionIDs(ids ...uuid.UUID) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed ids of sessions.
func (m *DeviceMutation) RemovedSessionsIDs() (ids []uuid.UUID) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the sessions ids in the mutation.
func (m *DeviceMutation) SessionsIDs() (ids []uuid.UUID) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions reset all changes of the "sessions" edge.
func (m *DeviceMutation) ResetSessions() {
	m.sessions = nil
	m.removedsessions = nil
}

// Op returns the operation name.
func (m *DeviceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Device).
func (m *DeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DeviceMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, device.FieldName)
	}
	if m.version != nil {
		fields = append(fields, device.FieldVersion)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case device.FieldName:
		return m.Name()
	case device.FieldVersion:
		return m.Version()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case device.FieldName:
		return m.OldName(ctx)
	case device.FieldVersion:
		return m.OldVersion(ctx)
	}
	return nil, fmt.Errorf("unknown Device field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case device.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case device.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DeviceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DeviceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Device numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DeviceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Device nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DeviceMutation) ResetField(name string) error {
	switch name {
	case device.FieldName:
		m.ResetName()
		return nil
	case device.FieldVersion:
		m.ResetVersion()
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.sessions != nil {
		edges = append(edges, device.EdgeSessions)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsessions != nil {
		edges = append(edges, device.EdgeSessions)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DeviceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DeviceMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DeviceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Device unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DeviceMutation) ResetEdge(name string) error {
	switch name {
	case device.EdgeSessions:
		m.ResetSessions()
		return nil
	}
	return fmt.Errorf("unknown Device edge %s", name)
}

// HostnameMutation represents an operation that mutate the Hostnames
// nodes in the graph.
type HostnameMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	clearedFields     map[string]struct{}
	page_stats        map[int]struct{}
	removedpage_stats map[int]struct{}
	done              bool
	oldValue          func(context.Context) (*Hostname, error)
}

var _ ent.Mutation = (*HostnameMutation)(nil)

// hostnameOption allows to manage the mutation configuration using functional options.
type hostnameOption func(*HostnameMutation)

// newHostnameMutation creates new mutation for $n.Name.
func newHostnameMutation(c config, op Op, opts ...hostnameOption) *HostnameMutation {
	m := &HostnameMutation{
		config:        c,
		op:            op,
		typ:           TypeHostname,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHostnameID sets the id field of the mutation.
func withHostnameID(id int) hostnameOption {
	return func(m *HostnameMutation) {
		var (
			err   error
			once  sync.Once
			value *Hostname
		)
		m.oldValue = func(ctx context.Context) (*Hostname, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Hostname.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHostname sets the old Hostname of the mutation.
func withHostname(node *Hostname) hostnameOption {
	return func(m *HostnameMutation) {
		m.oldValue = func(context.Context) (*Hostname, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HostnameMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HostnameMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *HostnameMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *HostnameMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *HostnameMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Hostname.
// If the Hostname object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HostnameMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *HostnameMutation) ResetName() {
	m.name = nil
}

// AddPageStatIDs adds the page_stats edge to PageStat by ids.
func (m *HostnameMutation) AddPageStatIDs(ids ...int) {
	if m.page_stats == nil {
		m.page_stats = make(map[int]struct{})
	}
	for i := range ids {
		m.page_stats[ids[i]] = struct{}{}
	}
}

// RemovePageStatIDs removes the page_stats edge to PageStat by ids.
func (m *HostnameMutation) RemovePageStatIDs(ids ...int) {
	if m.removedpage_stats == nil {
		m.removedpage_stats = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpage_stats[ids[i]] = struct{}{}
	}
}

// RemovedPageStats returns the removed ids of page_stats.
func (m *HostnameMutation) RemovedPageStatsIDs() (ids []int) {
	for id := range m.removedpage_stats {
		ids = append(ids, id)
	}
	return
}

// PageStatsIDs returns the page_stats ids in the mutation.
func (m *HostnameMutation) PageStatsIDs() (ids []int) {
	for id := range m.page_stats {
		ids = append(ids, id)
	}
	return
}

// ResetPageStats reset all changes of the "page_stats" edge.
func (m *HostnameMutation) ResetPageStats() {
	m.page_stats = nil
	m.removedpage_stats = nil
}

// Op returns the operation name.
func (m *HostnameMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Hostname).
func (m *HostnameMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *HostnameMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, hostname.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *HostnameMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hostname.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *HostnameMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hostname.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Hostname field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *HostnameMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hostname.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Hostname field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *HostnameMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *HostnameMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *HostnameMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Hostname numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *HostnameMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *HostnameMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *HostnameMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Hostname nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *HostnameMutation) ResetField(name string) error {
	switch name {
	case hostname.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Hostname field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *HostnameMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.page_stats != nil {
		edges = append(edges, hostname.EdgePageStats)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *HostnameMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hostname.EdgePageStats:
		ids := make([]ent.Value, 0, len(m.page_stats))
		for id := range m.page_stats {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *HostnameMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpage_stats != nil {
		edges = append(edges, hostname.EdgePageStats)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *HostnameMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hostname.EdgePageStats:
		ids := make([]ent.Value, 0, len(m.removedpage_stats))
		for id := range m.removedpage_stats {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *HostnameMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *HostnameMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *HostnameMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Hostname unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *HostnameMutation) ResetEdge(name string) error {
	switch name {
	case hostname.EdgePageStats:
		m.ResetPageStats()
		return nil
	}
	return fmt.Errorf("unknown Hostname edge %s", name)
}

// PageStatMutation represents an operation that mutate the PageStats
// nodes in the graph.
type PageStatMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	pageviews          *int
	addpageviews       *int
	visitors           *int
	addvisitors        *int
	entries            *int
	addentries         *int
	bounce_rate        *float64
	addbounce_rate     *float64
	known_durations    *int
	addknown_durations *int
	avg_duration       *float64
	addavg_duration    *float64
	date               *time.Time
	clearedFields      map[string]struct{}
	app                *int
	clearedapp         bool
	hostname           *int
	clearedhostname    bool
	pathname           *int
	clearedpathname    bool
	done               bool
	oldValue           func(context.Context) (*PageStat, error)
}

var _ ent.Mutation = (*PageStatMutation)(nil)

// pagestatOption allows to manage the mutation configuration using functional options.
type pagestatOption func(*PageStatMutation)

// newPageStatMutation creates new mutation for $n.Name.
func newPageStatMutation(c config, op Op, opts ...pagestatOption) *PageStatMutation {
	m := &PageStatMutation{
		config:        c,
		op:            op,
		typ:           TypePageStat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPageStatID sets the id field of the mutation.
func withPageStatID(id int) pagestatOption {
	return func(m *PageStatMutation) {
		var (
			err   error
			once  sync.Once
			value *PageStat
		)
		m.oldValue = func(ctx context.Context) (*PageStat, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PageStat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPageStat sets the old PageStat of the mutation.
func withPageStat(node *PageStat) pagestatOption {
	return func(m *PageStatMutation) {
		m.oldValue = func(context.Context) (*PageStat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PageStatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PageStatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PageStatMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPageviews sets the pageviews field.
func (m *PageStatMutation) SetPageviews(i int) {
	m.pageviews = &i
	m.addpageviews = nil
}

// Pageviews returns the pageviews value in the mutation.
func (m *PageStatMutation) Pageviews() (r int, exists bool) {
	v := m.pageviews
	if v == nil {
		return
	}
	return *v, true
}

// OldPageviews returns the old pageviews value of the PageStat.
// If the PageStat object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PageStatMutation) OldPageviews(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPageviews is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPageviews requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPageviews: %w", err)
	}
	return oldValue.Pageviews, nil
}

// AddPageviews adds i to pageviews.
func (m *PageStatMutation) AddPageviews(i int) {
	if m.addpageviews != nil {
		*m.addpageviews += i
	} else {
		m.addpageviews = &i
	}
}

// AddedPageviews returns the value that was added to the pageviews field in this mutation.
func (m *PageStatMutation) AddedPageviews() (r int, exists bool) {
	v := m.addpageviews
	if v == nil {
		return
	}
	return *v, true
}

// ResetPageviews reset all changes of the "pageviews" field.
func (m *PageStatMutation) ResetPageviews() {
	m.pageviews = nil
	m.addpageviews = nil
}

// SetVisitors sets the visitors field.
func (m *PageStatMutation) SetVisitors(i int) {
	m.visitors = &i
	m.addvisitors = nil
}

// Visitors returns the visitors value in the mutation.
func (m *PageStatMutation) Visitors() (r int, exists bool) {
	v := m.visitors
	if v == nil {
		return
	}
	return *v, true
}

// OldVisitors returns the old visitors value of the PageStat.
// If the PageStat object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PageStatMutation) OldVisitors(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVisitors is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVisitors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisitors: %w", err)
	}
	return oldValue.Visitors, nil
}

// AddVisitors adds i to visitors.
func (m *PageStatMutation) AddVisitors(i int) {
	if m.addvisitors != nil {
		*m.addvisitors += i
	} else {
		m.addvisitors = &i
	}
}

// AddedVisitors returns the value that was added to the visitors field in this mutation.
func (m *PageStatMutation) AddedVisitors() (r int, exists bool) {
	v := m.addvisitors
	if v == nil {
		return
	}
	return *v, true
}

// ResetVisitors reset all changes of the "visitors" field.
func (m *PageStatMutation) ResetVisitors() {
	m.visitors = nil
	m.addvisitors = nil
}

// SetEntries sets the entries field.
func (m *PageStatMutation) SetEntries(i int) {
	m.entries = &i
	m.addentries = nil
}

// Entries returns the entries value in the mutation.
func (m *PageStatMutation) Entries() (r int, exists bool) {
	v := m.entries
	if v == nil {
		return
	}
	return *v, true
}

// OldEntries returns the old entries value of the PageStat.
// If the PageStat object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PageStatMutation) OldEntries(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEntries is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEntries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntries: %w", err)
	}
	return oldValue.Entries, nil
}

// AddEntries adds i to entries.
func (m *PageStatMutation) AddEntries(i int) {
	if m.addentries != nil {
		*m.addentries += i
	} else {
		m.addentries = &i
	}
}

// AddedEntries returns the value that was added to the entries field in this mutation.
func (m *PageStatMutation) AddedEntries() (r int, exists bool) {
	v := m.addentries
	if v == nil {
		return
	}
	return *v, true
}

// ResetEntries reset all changes of the "entries" field.
func (m *PageStatMutation) ResetEntries() {
	m.entries = nil
	m.addentries = nil
}

// SetBounceRate sets the bounce_rate field.
func (m *PageStatMutation) SetBounceRate(f float64) {
	m.bounce_rate = &f
	m.addbounce_rate = nil
}

// BounceRate returns the bounce_rate value in the mutation.
func (m *PageStatMutation) BounceRate() (r float64, exists bool) {
	v := m.bounce_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldBounceRate returns the old bounce_rate value of the PageStat.
// If the PageStat object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PageStatMutation) OldBounceRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBounceRate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBounceRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBounceRate: %w", err)
	}
	return oldValue.BounceRate, nil
}

// AddBounceRate adds f to bounce_rate.
func (m *PageStatMutation) AddBounceRate(f float64) {
	if m.addbounce_rate != nil {
		*m.addbounce_rate += f
	} else {
		m.addbounce_rate = &f
	}
}

// AddedBounceRate returns the value that was added to the bounce_rate field in this mutation.
func (m *PageStatMutation) AddedBounceRate() (r float64, exists bool) {
	v := m.addbounce_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetBounceRate reset all changes of the "bounce_rate" field.
func (m *PageStatMutation) ResetBounceRate() {
	m.bounce_rate = nil
	m.addbounce_rate = nil
}

// SetKnownDurations sets the known_durations field.
func (m *PageStatMutation) SetKnownDurations(i int) {
	m.known_durations = &i
	m.addknown_durations = nil
}

// KnownDurations returns the known_durations value in the mutation.
func (m *PageStatMutation) KnownDurations() (r int, exists bool) {
	v := m.known_durations
	if v == nil {
		return
	}
	return *v, true
}

// OldKnownDurations returns the old known_durations value of the PageStat.
// If the PageStat object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PageStatMutation) OldKnownDurations(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKnownDurations is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKnownDurations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKnownDurations: %w", err)
	}
	return oldValue.KnownDurations, nil
}

// AddKnownDurations adds i to known_durations.
func (m *PageStatMutation) AddKnownDurations(i int) {
	if m.addknown_durations != nil {
		*m.addknown_durations += i
	} else {
		m.addknown_durations = &i
	}
}

// AddedKnownDurations returns the value that was added to the known_durations field in this mutation.
func (m *PageStatMutation) AddedKnownDurations() (r int, exists bool) {
	v := m.addknown_durations
	if v == nil {
		return
	}
	return *v, true
}

// ResetKnownDurations reset all changes of the "known_durations" field.
func (m *PageStatMutation) ResetKnownDurations() {
	m.known_durations = nil
	m.addknown_durations = nil
}

// SetAvgDuration sets the avg_duration field.
func (m *PageStatMutation) SetAvgDuration(f float64) {
	m.avg_duration = &f
	m.addavg_duration = nil
}

// AvgDuration returns the avg_duration value in the mutation.
func (m *PageStatMutation) AvgDuration() (r float64, exists bool) {
	v := m.avg_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldAvgDuration returns the old avg_duration value of the PageStat.
// If the PageStat object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PageStatMutation) OldAvgDuration(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAvgDuration is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAvgDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvgDuration: %w", err)
	}
	return oldValue.AvgDuration, nil
}

// AddAvgDuration adds f to avg_duration.
func (m *PageStatMutation) AddAvgDuration(f float64) {
	if m.addavg_duration != nil {
		*m.addavg_duration += f
	} else {
		m.addavg_duration = &f
	}
}

// AddedAvgDuration returns the value that was added to the avg_duration field in this mutation.
func (m *PageStatMutation) AddedAvgDuration() (r float64, exists bool) {
	v := m.addavg_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetAvgDuration reset all changes of the "avg_duration" field.
func (m *PageStatMutation) ResetAvgDuration() {
	m.avg_duration = nil
	m.addavg_duration = nil
}

// SetDate sets the date field.
func (m *PageStatMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the date value in the mutation.
func (m *PageStatMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old date value of the PageStat.
// If the PageStat object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PageStatMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate reset all changes of the "date" field.
func (m *PageStatMutation) ResetDate() {
	m.date = nil
}

// SetAppID sets the app edge to App by id.
func (m *PageStatMutation) SetAppID(id int) {
	m.app = &id
}

// ClearApp clears the app edge to App.
func (m *PageStatMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared returns if the edge app was cleared.
func (m *PageStatMutation) AppCleared() bool {
	return m.clearedapp
}

// AppID returns the app id in the mutation.
func (m *PageStatMutation) AppID() (id int, exists bool) {
	if m.app != nil {
		return *m.app, true
	}
	return
}

// AppIDs returns the app ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *PageStatMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp reset all changes of the "app" edge.
func (m *PageStatMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// SetHostnameID sets the hostname edge to Hostname by id.
func (m *PageStatMutation) SetHostnameID(id int) {
	m.hostname = &id
}

// ClearHostname clears the hostname edge to Hostname.
func (m *PageStatMutation) ClearHostname() {
	m.clearedhostname = true
}

// HostnameCleared returns if the edge hostname was cleared.
func (m *PageStatMutation) HostnameCleared() bool {
	return m.clearedhostname
}

// HostnameID returns the hostname id in the mutation.
func (m *PageStatMutation) HostnameID() (id int, exists bool) {
	if m.hostname != nil {
		return *m.hostname, true
	}
	return
}

// HostnameIDs returns the hostname ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// HostnameID instead. It exists only for internal usage by the builders.
func (m *PageStatMutation) HostnameIDs() (ids []int) {
	if id := m.hostname; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHostname reset all changes of the "hostname" edge.
func (m *PageStatMutation) ResetHostname() {
	m.hostname = nil
	m.clearedhostname = false
}

// SetPathnameID sets the pathname edge to Pathname by id.
func (m *PageStatMutation) SetPathnameID(id int) {
	m.pathname = &id
}

// ClearPathname clears the pathname edge to Pathname.
func (m *PageStatMutation) ClearPathname() {
	m.clearedpathname = true
}

// PathnameCleared returns if the edge pathname was cleared.
func (m *PageStatMutation) PathnameCleared() bool {
	return m.clearedpathname
}

// PathnameID returns the pathname id in the mutation.
func (m *PageStatMutation) PathnameID() (id int, exists bool) {
	if m.pathname != nil {
		return *m.pathname, true
	}
	return
}

// PathnameIDs returns the pathname ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PathnameID instead. It exists only for internal usage by the builders.
func (m *PageStatMutation) PathnameIDs() (ids []int) {
	if id := m.pathname; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPathname reset all changes of the "pathname" edge.
func (m *PageStatMutation) ResetPathname() {
	m.pathname = nil
	m.clearedpathname = false
}

// Op returns the operation name.
func (m *PageStatMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PageStat).
func (m *PageStatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PageStatMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.pageviews != nil {
		fields = append(fields, pagestat.FieldPageviews)
	}
	if m.visitors != nil {
		fields = append(fields, pagestat.FieldVisitors)
	}
	if m.entries != nil {
		fields = append(fields, pagestat.FieldEntries)
	}
	if m.bounce_rate != nil {
		fields = append(fields, pagestat.FieldBounceRate)
	}
	if m.known_durations != nil {
		fields = append(fields, pagestat.FieldKnownDurations)
	}
	if m.avg_duration != nil {
		fields = append(fields, pagestat.FieldAvgDuration)
	}
	if m.date != nil {
		fields = append(fields, pagestat.FieldDate)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PageStatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pagestat.FieldPageviews:
		return m.Pageviews()
	case pagestat.FieldVisitors:
		return m.Visitors()
	case pagestat.FieldEntries:
		return m.Entries()
	case pagestat.FieldBounceRate:
		return m.BounceRate()
	case pagestat.FieldKnownDurations:
		return m.KnownDurations()
	case pagestat.FieldAvgDuration:
		return m.AvgDuration()
	case pagestat.FieldDate:
		return m.Date()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PageStatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pagestat.FieldPageviews:
		return m.OldPageviews(ctx)
	case pagestat.FieldVisitors:
		return m.OldVisitors(ctx)
	case pagestat.FieldEntries:
		return m.OldEntries(ctx)
	case pagestat.FieldBounceRate:
		return m.OldBounceRate(ctx)
	case pagestat.FieldKnownDurations:
		return m.OldKnownDurations(ctx)
	case pagestat.FieldAvgDuration:
		return m.OldAvgDuration(ctx)
	case pagestat.FieldDate:
		return m.OldDate(ctx)
	}
	return nil, fmt.Errorf("unknown PageStat field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PageStatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pagestat.FieldPageviews:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPageviews(v)
		return nil
	case pagestat.FieldVisitors:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisitors(v)
		return nil
	case pagestat.FieldEntries:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntries(v)
		return nil
	case pagestat.FieldBounceRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBounceRate(v)
		return nil
	case pagestat.FieldKnownDurations:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKnownDurations(v)
		return nil
	case pagestat.FieldAvgDuration:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvgDuration(v)
		return nil
	case pagestat.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	}
	return fmt.Errorf("unknown PageStat field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PageStatMutation) AddedFields() []string {
	var fields []string
	if m.addpageviews != nil {
		fields = append(fields, pagestat.FieldPageviews)
	}
	if m.addvisitors != nil {
		fields = append(fields, pagestat.FieldVisitors)
	}
	if m.addentries != nil {
		fields = append(fields, pagestat.FieldEntries)
	}
	if m.addbounce_rate != nil {
		fields = append(fields, pagestat.FieldBounceRate)
	}
	if m.addknown_durations != nil {
		fields = append(fields, pagestat.FieldKnownDurations)
	}
	if m.addavg_duration != nil {
		fields = append(fields, pagestat.FieldAvgDuration)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PageStatMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pagestat.FieldPageviews:
		return m.AddedPageviews()
	case pagestat.FieldVisitors:
		return m.AddedVisitors()
	case pagestat.FieldEntries:
		return m.AddedEntries()
	case pagestat.FieldBounceRate:
		return m.AddedBounceRate()
	case pagestat.FieldKnownDurations:
		return m.AddedKnownDurations()
	case pagestat.FieldAvgDuration:
		return m.AddedAvgDuration()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PageStatMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pagestat.FieldPageviews:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPageviews(v)
		return nil
	case pagestat.FieldVisitors:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVisitors(v)
		return nil
	case pagestat.FieldEntries:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEntries(v)
		return nil
	case pagestat.FieldBounceRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBounceRate(v)
		return nil
	case pagestat.FieldKnownDurations:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddKnownDurations(v)
		return nil
	case pagestat.FieldAvgDuration:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvgDuration(v)
		return nil
	}
	return fmt.Errorf("unknown PageStat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PageStatMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PageStatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PageStatMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PageStat nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PageStatMutation) ResetField(name string) error {
	switch name {
	case pagestat.FieldPageviews:
		m.ResetPageviews()
		return nil
	case pagestat.FieldVisitors:
		m.ResetVisitors()
		return nil
	case pagestat.FieldEntries:
		m.ResetEntries()
		return nil
	case pagestat.FieldBounceRate:
		m.ResetBounceRate()
		return nil
	case pagestat.FieldKnownDurations:
		m.ResetKnownDurations()
		return nil
	case pagestat.FieldAvgDuration:
		m.ResetAvgDuration()
		return nil
	case pagestat.FieldDate:
		m.ResetDate()
		return nil
	}
	return fmt.Errorf("unknown PageStat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PageStatMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.app != nil {
		edges = append(edges, pagestat.EdgeApp)
	}
	if m.hostname != nil {
		edges = append(edges, pagestat.EdgeHostname)
	}
	if m.pathname != nil {
		edges = append(edges, pagestat.EdgePathname)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PageStatMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pagestat.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case pagestat.EdgeHostname:
		if id := m.hostname; id != nil {
			return []ent.Value{*id}
		}
	case pagestat.EdgePathname:
		if id := m.pathname; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PageStatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PageStatMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PageStatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedapp {
		edges = append(edges, pagestat.EdgeApp)
	}
	if m.clearedhostname {
		edges = append(edges, pagestat.EdgeHostname)
	}
	if m.clearedpathname {
		edges = append(edges, pagestat.EdgePathname)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PageStatMutation) EdgeCleared(name string) bool {
	switch name {
	case pagestat.EdgeApp:
		return m.clearedapp
	case pagestat.EdgeHostname:
		return m.clearedhostname
	case pagestat.EdgePathname:
		return m.clearedpathname
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PageStatMutation) ClearEdge(name string) error {
	switch name {
	case pagestat.EdgeApp:
		m.ClearApp()
		return nil
	case pagestat.EdgeHostname:
		m.ClearHostname()
		return nil
	case pagestat.EdgePathname:
		m.ClearPathname()
		return nil
	}
	return fmt.Errorf("unknown PageStat unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PageStatMutation) ResetEdge(name string) error {
	switch name {
	case pagestat.EdgeApp:
		m.ResetApp()
		return nil
	case pagestat.EdgeHostname:
		m.ResetHostname()
		return nil
	case pagestat.EdgePathname:
		m.ResetPathname()
		return nil
	}
	return fmt.Errorf("unknown PageStat edge %s", name)
}

// PageViewMutation represents an operation that mutate the PageViews
// nodes in the graph.
type PageViewMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	hostname       *string
	pathname       *string
	referrer       *string
	is_entry       *bool
	is_finished    *bool
	duration       *int
	addduration    *int
	timestamp      *time.Time
	user_agent     *string
	ip_address     *string
	screen_dim     *string
	extra          *map[string]interface{}
	clearedFields  map[string]struct{}
	app            *int
	clearedapp     bool
	session        *uuid.UUID
	clearedsession bool
	user           *string
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*PageView, error)
}

var _ ent.Mutation = (*PageViewMutation)(nil)

// pageviewOption allows to manage the mutation configuration using functional options.
type pageviewOption func(*PageViewMutation)

// newPageViewMutation creates new mutation for $n.Name.
func newPageViewMutation(c config, op Op, opts ...pageviewOption) *PageViewMutation {
	m := &PageViewMutation{
		config:        c,
		op:            op,
		typ:           TypePageView,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPageViewID sets the id field of the mutation.
func withPageViewID(id uuid.UUID) pageviewOption {
	return func(m *PageViewMutation) {
		var (
			err   error
			once  sync.Once
			value *PageView
		)
		m.oldValue = func(ctx context.Context) (*PageView, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PageView.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPageView sets the old PageView of the mutation.
func withPageView(node *PageView) pageviewOption {
	return func(m *PageViewMutation) {
		m.oldValue = func(context.Context) (*PageView, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PageViewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PageViewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on PageView creation.
func (m *PageViewMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PageViewMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetHostname sets the hostname field.
func (m *PageViewMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the hostname value in the mutation.
func (m *PageViewMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old hostname value of the PageView.
// If the PageView object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PageViewMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHostname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ResetHostname reset all changes of the "hostname" field.
func (m *PageViewMutation) ResetHostname() {
	m.hostname = nil
}

// SetPathname sets the pathname field.
func (m *PageViewMutation) SetPathname(s string) {
	m.pathname = &s
}

// Pathname returns the pathname value in the mutation.
func (m *PageViewMutation) Pathname() (r string, exists bool) {
	v := m.pathname
	if v == nil {
		return
	}
	return *v, true
}

// OldPathname returns the old pathname value of the PageView.
// If the PageView object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PageViewMutation) OldPathname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPathname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPathname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPathname: %w", err)
	}
	return oldValue.Pathname, nil
}

// ResetPathname reset all changes of the "pathname" field.
func (m *PageViewMutation) ResetPathname() {
	m.pathname = nil
}

// SetReferrer sets the referrer field.
func (m *PageViewMutation) SetReferrer(s string) {
	m.referrer = &s
}

// Referrer returns the referrer value in the mutation.
func (m *PageViewMutation) Referrer() (r string, exists bool) {
	v := m.referrer
	if v == nil {
		return
	}
	return *v, true
}

// OldReferrer returns the old referrer value of the PageView.
// If the PageView object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PageViewMutation) OldReferrer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReferrer is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReferrer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferrer: %w", err)
	}
	return oldValue.Referrer, nil
}

// ResetReferrer reset all changes of the "referrer" field.
func (m *PageViewMutation) ResetReferrer() {
	m.referrer = nil
}

// SetIsEntry sets the is_entry field.
func (m *PageViewMutation) SetIsEntry(b bool) {
	m.is_entry = &b
}

// IsEntry returns the is_entry value in the mutation.
func (m *PageViewMutation) IsEntry() (r bool, exists bool) {
	v := m.is_entry
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEntry returns the old is_entry value of the PageView.
// If the PageView object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PageViewMutation) OldIsEntry(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsEntry is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsEntry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEntry: %w", err)
	}
	return oldValue.IsEntry, nil
}

// ResetIsEntry reset all changes of the "is_entry" field.
func (m *PageViewMutation) ResetIsEntry() {
	m.is_entry = nil
}

// SetIsFinished sets the is_finished field.
func (m *PageViewMutation) SetIsFinished(b bool) {
	m.is_finished = &b
}

// IsFinished returns the is_finished value in the mutation.
func (m *PageViewMutation) IsFinished() (r bool, exists bool) {
	v := m.is_finished
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFinished returns the old is_finished value of the PageView.
// If the PageView object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PageViewMutation) OldIsFinished(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsFinished is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsFinished requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFinished: %w", err)
	}
	return oldValue.IsFinished, nil
}

// ResetIsFinished reset all changes of the "is_finished" field.
func (m *PageViewMutation) ResetIsFinished() {
	m.is_finished = nil
}

// SetDuration sets the duration field.
func (m *PageViewMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the duration value in the mutation.
func (m *PageViewMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old duration value of the PageView.
// If the PageView object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PageViewMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDuration is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to duration.
func (m *PageViewMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the duration field in this mutation.
func (m *PageViewMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration reset all changes of the "duration" field.
func (m *PageViewMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetTimestamp sets the timestamp field.
func (m *PageViewMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the timestamp value in the mutation.
func (m *PageViewMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old timestamp value of the PageView.
// If the PageView object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PageViewMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimestamp is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp reset all changes of the "timestamp" field.
func (m *PageViewMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetUserAgent sets the user_agent field.
func (m *PageViewMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the user_agent value in the mutation.
func (m *PageViewMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old user_agent value of the PageView.
// If the PageView object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PageViewMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserAgent is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of user_agent.
func (m *PageViewMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[pageview.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the field user_agent was cleared in this mutation.
func (m *PageViewMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[pageview.FieldUserAgent]
	return ok
}

// ResetUserAgent reset all changes of the "user_agent" field.
func (m *PageViewMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, pageview.FieldUserAgent)
}

// SetIPAddress sets the ip_address field.
func (m *PageViewMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the ip_address value in the mutation.
func (m *PageViewMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old ip_address value of the PageView.
// If the PageView object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PageViewMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIPAddress is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of ip_address.
func (m *PageViewMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[pageview.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the field ip_address was cleared in this mutation.
func (m *PageViewMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[pageview.FieldIPAddress]
	return ok
}

// ResetIPAddress reset all changes of the "ip_address" field.
func (m *PageViewMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, pageview.FieldIPAddress)
}

// SetScreenDim sets the screen_dim field.
func (m *PageViewMutation) SetScreenDim(s string) {
	m.screen_dim = &s
}

// ScreenDim returns the screen_dim value in the mutation.
func (m *PageViewMutation) ScreenDim() (r string, exists bool) {
	v := m.screen_dim
	if v == nil {
		return
	}
	return *v, true
}

// OldScreenDim returns the old screen_dim value of the PageView.
// If the PageView object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PageViewMutation) OldScreenDim(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldScreenDim is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldScreenDim requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScreenDim: %w", err)
	}
	return oldValue.ScreenDim, nil
}

// ClearScreenDim clears the value of screen_dim.
func (m *PageViewMutation) ClearScreenDim() {
	m.screen_dim = nil
	m.clearedFields[pageview.FieldScreenDim] = struct{}{}
}

// ScreenDimCleared returns if the field screen_dim was cleared in this mutation.
func (m *PageViewMutation) ScreenDimCleared() bool {
	_, ok := m.clearedFields[pageview.FieldScreenDim]
	return ok
}

// ResetScreenDim reset all changes of the "screen_dim" field.
func (m *PageViewMutation) ResetScreenDim() {
	m.screen_dim = nil
	delete(m.clearedFields, pageview.FieldScreenDim)
}

// SetExtra sets the extra field.
func (m *PageViewMutation) SetExtra(value map[string]interface{}) {
	m.extra = &value
}

// Extra returns the extra value in the mutation.
func (m *PageViewMutation) Extra() (r map[string]interface{}, exists bool) {
	v := m.extra
	if v == nil {
		return
	}
	return *v, true
}

// OldExtra returns the old extra value of the PageView.
// If the PageView object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PageViewMutation) OldExtra(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExtra is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExtra requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtra: %w", err)
	}
	return oldValue.Extra, nil
}

// ClearExtra clears the value of extra.
func (m *PageViewMutation) ClearExtra() {
	m.extra = nil
	m.clearedFields[pageview.FieldExtra] = struct{}{}
}

// ExtraCleared returns if the field extra was cleared in this mutation.
func (m *PageViewMutation) ExtraCleared() bool {
	_, ok := m.clearedFields[pageview.FieldExtra]
	return ok
}

// ResetExtra reset all changes of the "extra" field.
func (m *PageViewMutation) ResetExtra() {
	m.extra = nil
	delete(m.clearedFields, pageview.FieldExtra)
}

// SetAppID sets the app edge to App by id.
func (m *PageViewMutation) SetAppID(id int) {
	m.app = &id
}

// ClearApp clears the app edge to App.
func (m *PageViewMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared returns if the edge app was cleared.
func (m *PageViewMutation) AppCleared() bool {
	return m.clearedapp
}

// AppID returns the app id in the mutation.
func (m *PageViewMutation) AppID() (id int, exists bool) {
	if m.app != nil {
		return *m.app, true
	}
	return
}

// AppIDs returns the app ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *PageViewMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp reset all changes of the "app" edge.
func (m *PageViewMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// SetSessionID sets the session edge to Session by id.
func (m *PageViewMutation) SetSessionID(id uuid.UUID) {
	m.session = &id
}

// ClearSession clears the session edge to Session.
func (m *PageViewMutation) ClearSession() {
	m.clearedsession = true
}

// SessionCleared returns if the edge session was cleared.
func (m *PageViewMutation) SessionCleared() bool {
	return m.clearedsession
}

// SessionID returns the session id in the mutation.
func (m *PageViewMutation) SessionID() (id uuid.UUID, exists bool) {
	if m.session != nil {
		return *m.session, true
	}
	return
}

// SessionIDs returns the session ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *PageViewMutation) SessionIDs() (ids []uuid.UUID) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession reset all changes of the "session" edge.
func (m *PageViewMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// SetUserID sets the user edge to User by id.
func (m *PageViewMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the user edge to User.
func (m *PageViewMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *PageViewMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the user id in the mutation.
func (m *PageViewMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the user ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PageViewMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *PageViewMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Op returns the operation name.
func (m *PageViewMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PageView).
func (m *PageViewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PageViewMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.hostname != nil {
		fields = append(fields, pageview.FieldHostname)
	}
	if m.pathname != nil {
		fields = append(fields, pageview.FieldPathname)
	}
	if m.referrer != nil {
		fields = append(fields, pageview.FieldReferrer)
	}
	if m.is_entry != nil {
		fields = append(fields, pageview.FieldIsEntry)
	}
	if m.is_finished != nil {
		fields = append(fields, pageview.FieldIsFinished)
	}
	if m.duration != nil {
		fields = append(fields, pageview.FieldDuration)
	}
	if m.timestamp != nil {
		fields = append(fields, pageview.FieldTimestamp)
	}
	if m.user_agent != nil {
		fields = append(fields, pageview.FieldUserAgent)
	}
	if m.ip_address != nil {
		fields = append(fields, pageview.FieldIPAddress)
	}
	if m.screen_dim != nil {
		fields = append(fields, pageview.FieldScreenDim)
	}
	if m.extra != nil {
		fields = append(fields, pageview.FieldExtra)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PageViewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pageview.FieldHostname:
		return m.Hostname()
	case pageview.FieldPathname:
		return m.Pathname()
	case pageview.FieldReferrer:
		return m.Referrer()
	case pageview.FieldIsEntry:
		return m.IsEntry()
	case pageview.FieldIsFinished:
		return m.IsFinished()
	case pageview.FieldDuration:
		return m.Duration()
	case pageview.FieldTimestamp:
		return m.Timestamp()
	case pageview.FieldUserAgent:
		return m.UserAgent()
	case pageview.FieldIPAddress:
		return m.IPAddress()
	case pageview.FieldScreenDim:
		return m.ScreenDim()
	case pageview.FieldExtra:
		return m.Extra()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PageViewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pageview.FieldHostname:
		return m.OldHostname(ctx)
	case pageview.FieldPathname:
		return m.OldPathname(ctx)
	case pageview.FieldReferrer:
		return m.OldReferrer(ctx)
	case pageview.FieldIsEntry:
		return m.OldIsEntry(ctx)
	case pageview.FieldIsFinished:
		return m.OldIsFinished(ctx)
	case pageview.FieldDuration:
		return m.OldDuration(ctx)
	case pageview.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case pageview.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case pageview.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case pageview.FieldScreenDim:
		return m.OldScreenDim(ctx)
	case pageview.FieldExtra:
		return m.OldExtra(ctx)
	}
	return nil, fmt.Errorf("unknown PageView field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PageViewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pageview.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case pageview.FieldPathname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPathname(v)
		return nil
	case pageview.FieldReferrer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferrer(v)
		return nil
	case pageview.FieldIsEntry:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEntry(v)
		return nil
	case pageview.FieldIsFinished:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFinished(v)
		return nil
	case pageview.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case pageview.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case pageview.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case pageview.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case pageview.FieldScreenDim:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScreenDim(v)
		return nil
	case pageview.FieldExtra:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtra(v)
		return nil
	}
	return fmt.Errorf("unknown PageView field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PageViewMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, pageview.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PageViewMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pageview.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PageViewMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pageview.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown PageView numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PageViewMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pageview.FieldUserAgent) {
		fields = append(fields, pageview.FieldUserAgent)
	}
	if m.FieldCleared(pageview.FieldIPAddress) {
		fields = append(fields, pageview.FieldIPAddress)
	}
	if m.FieldCleared(pageview.FieldScreenDim) {
		fields = append(fields, pageview.FieldScreenDim)
	}
	if m.FieldCleared(pageview.FieldExtra) {
		fields = append(fields, pageview.FieldExtra)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PageViewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PageViewMutation) ClearField(name string) error {
	switch name {
	case pageview.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case pageview.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case pageview.FieldScreenDim:
		m.ClearScreenDim()
		return nil
	case pageview.FieldExtra:
		m.ClearExtra()
		return nil
	}
	return fmt.Errorf("unknown PageView nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PageViewMutation) ResetField(name string) error {
	switch name {
	case pageview.FieldHostname:
		m.ResetHostname()
		return nil
	case pageview.FieldPathname:
		m.ResetPathname()
		return nil
	case pageview.FieldReferrer:
		m.ResetReferrer()
		return nil
	case pageview.FieldIsEntry:
		m.ResetIsEntry()
		return nil
	case pageview.FieldIsFinished:
		m.ResetIsFinished()
		return nil
	case pageview.FieldDuration:
		m.ResetDuration()
		return nil
	case pageview.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case pageview.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case pageview.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case pageview.FieldScreenDim:
		m.ResetScreenDim()
		return nil
	case pageview.FieldExtra:
		m.ResetExtra()
		return nil
	}
	return fmt.Errorf("unknown PageView field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PageViewMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.app != nil {
		edges = append(edges, pageview.EdgeApp)
	}
	if m.session != nil {
		edges = append(edges, pageview.EdgeSession)
	}
	if m.user != nil {
		edges = append(edges, pageview.EdgeUser)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PageViewMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pageview.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case pageview.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	case pageview.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PageViewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PageViewMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PageViewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedapp {
		edges = append(edges, pageview.EdgeApp)
	}
	if m.clearedsession {
		edges = append(edges, pageview.EdgeSession)
	}
	if m.cleareduser {
		edges = append(edges, pageview.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PageViewMutation) EdgeCleared(name string) bool {
	switch name {
	case pageview.EdgeApp:
		return m.clearedapp
	case pageview.EdgeSession:
		return m.clearedsession
	case pageview.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PageViewMutation) ClearEdge(name string) error {
	switch name {
	case pageview.EdgeApp:
		m.ClearApp()
		return nil
	case pageview.EdgeSession:
		m.ClearSession()
		return nil
	case pageview.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown PageView unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PageViewMutation) ResetEdge(name string) error {
	switch name {
	case pageview.EdgeApp:
		m.ResetApp()
		return nil
	case pageview.EdgeSession:
		m.ResetSession()
		return nil
	case pageview.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown PageView edge %s", name)
}

// PathnameMutation represents an operation that mutate the Pathnames
// nodes in the graph.
type PathnameMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	clearedFields     map[string]struct{}
	page_stats        map[int]struct{}
	removedpage_stats map[int]struct{}
	done              bool
	oldValue          func(context.Context) (*Pathname, error)
}

var _ ent.Mutation = (*PathnameMutation)(nil)

// pathnameOption allows to manage the mutation configuration using functional options.
type pathnameOption func(*PathnameMutation)

// newPathnameMutation creates new mutation for $n.Name.
func newPathnameMutation(c config, op Op, opts ...pathnameOption) *PathnameMutation {
	m := &PathnameMutation{
		config:        c,
		op:            op,
		typ:           TypePathname,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPathnameID sets the id field of the mutation.
func withPathnameID(id int) pathnameOption {
	return func(m *PathnameMutation) {
		var (
			err   error
			once  sync.Once
			value *Pathname
		)
		m.oldValue = func(ctx context.Context) (*Pathname, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pathname.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPathname sets the old Pathname of the mutation.
func withPathname(node *Pathname) pathnameOption {
	return func(m *PathnameMutation) {
		m.oldValue = func(context.Context) (*Pathname, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PathnameMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PathnameMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PathnameMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *PathnameMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *PathnameMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Pathname.
// If the Pathname object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PathnameMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *PathnameMutation) ResetName() {
	m.name = nil
}

// AddPageStatIDs adds the page_stats edge to PageStat by ids.
func (m *PathnameMutation) AddPageStatIDs(ids ...int) {
	if m.page_stats == nil {
		m.page_stats = make(map[int]struct{})
	}
	for i := range ids {
		m.page_stats[ids[i]] = struct{}{}
	}
}

// RemovePageStatIDs removes the page_stats edge to PageStat by ids.
func (m *PathnameMutation) RemovePageStatIDs(ids ...int) {
	if m.removedpage_stats == nil {
		m.removedpage_stats = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpage_stats[ids[i]] = struct{}{}
	}
}

// RemovedPageStats returns the removed ids of page_stats.
func (m *PathnameMutation) RemovedPageStatsIDs() (ids []int) {
	for id := range m.removedpage_stats {
		ids = append(ids, id)
	}
	return
}

// PageStatsIDs returns the page_stats ids in the mutation.
func (m *PathnameMutation) PageStatsIDs() (ids []int) {
	for id := range m.page_stats {
		ids = append(ids, id)
	}
	return
}

// ResetPageStats reset all changes of the "page_stats" edge.
func (m *PathnameMutation) ResetPageStats() {
	m.page_stats = nil
	m.removedpage_stats = nil
}

// Op returns the operation name.
func (m *PathnameMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Pathname).
func (m *PathnameMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PathnameMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, pathname.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PathnameMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pathname.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PathnameMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pathname.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Pathname field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PathnameMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pathname.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Pathname field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PathnameMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PathnameMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PathnameMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Pathname numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PathnameMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PathnameMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PathnameMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Pathname nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PathnameMutation) ResetField(name string) error {
	switch name {
	case pathname.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Pathname field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PathnameMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.page_stats != nil {
		edges = append(edges, pathname.EdgePageStats)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PathnameMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pathname.EdgePageStats:
		ids := make([]ent.Value, 0, len(m.page_stats))
		for id := range m.page_stats {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PathnameMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpage_stats != nil {
		edges = append(edges, pathname.EdgePageStats)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PathnameMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case pathname.EdgePageStats:
		ids := make([]ent.Value, 0, len(m.removedpage_stats))
		for id := range m.removedpage_stats {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PathnameMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PathnameMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PathnameMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Pathname unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PathnameMutation) ResetEdge(name string) error {
	switch name {
	case pathname.EdgePageStats:
		m.ResetPageStats()
		return nil
	}
	return fmt.Errorf("unknown Pathname edge %s", name)
}

// ScreenMutation represents an operation that mutate the Screens
// nodes in the graph.
type ScreenMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Screen, error)
}

var _ ent.Mutation = (*ScreenMutation)(nil)

// screenOption allows to manage the mutation configuration using functional options.
type screenOption func(*ScreenMutation)

// newScreenMutation creates new mutation for $n.Name.
func newScreenMutation(c config, op Op, opts ...screenOption) *ScreenMutation {
	m := &ScreenMutation{
		config:        c,
		op:            op,
		typ:           TypeScreen,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScreenID sets the id field of the mutation.
func withScreenID(id int) screenOption {
	return func(m *ScreenMutation) {
		var (
			err   error
			once  sync.Once
			value *Screen
		)
		m.oldValue = func(ctx context.Context) (*Screen, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Screen.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScreen sets the old Screen of the mutation.
func withScreen(node *Screen) screenOption {
	return func(m *ScreenMutation) {
		m.oldValue = func(context.Context) (*Screen, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScreenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScreenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ScreenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// Op returns the operation name.
func (m *ScreenMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Screen).
func (m *ScreenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ScreenMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ScreenMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ScreenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Screen field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ScreenMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Screen field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ScreenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ScreenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ScreenMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Screen numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ScreenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ScreenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScreenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Screen nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ScreenMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Screen field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ScreenMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ScreenMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ScreenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ScreenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ScreenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ScreenMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ScreenMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Screen unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ScreenMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Screen edge %s", name)
}

// SessionMutation represents an operation that mutate the Sessions
// nodes in the graph.
type SessionMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	new_user         *bool
	is_unique        *bool
	is_bounce        *bool
	is_finished      *bool
	duration         *int
	addduration      *int
	started_at       *time.Time
	finished_at      *time.Time
	clearedFields    map[string]struct{}
	app              *int
	clearedapp       bool
	user             *string
	cleareduser      bool
	device           *string
	cleareddevice    bool
	pageviews        map[uuid.UUID]struct{}
	removedpageviews map[uuid.UUID]struct{}
	done             bool
	oldValue         func(context.Context) (*Session, error)
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows to manage the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for $n.Name.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the id field of the mutation.
func withSessionID(id uuid.UUID) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Session creation.
func (m *SessionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SessionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetNewUser sets the new_user field.
func (m *SessionMutation) SetNewUser(b bool) {
	m.new_user = &b
}

// NewUser returns the new_user value in the mutation.
func (m *SessionMutation) NewUser() (r bool, exists bool) {
	v := m.new_user
	if v == nil {
		return
	}
	return *v, true
}

// OldNewUser returns the old new_user value of the Session.
// If the Session object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SessionMutation) OldNewUser(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNewUser is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNewUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNewUser: %w", err)
	}
	return oldValue.NewUser, nil
}

// ResetNewUser reset all changes of the "new_user" field.
func (m *SessionMutation) ResetNewUser() {
	m.new_user = nil
}

// SetIsUnique sets the is_unique field.
func (m *SessionMutation) SetIsUnique(b bool) {
	m.is_unique = &b
}

// IsUnique returns the is_unique value in the mutation.
func (m *SessionMutation) IsUnique() (r bool, exists bool) {
	v := m.is_unique
	if v == nil {
		return
	}
	return *v, true
}

// OldIsUnique returns the old is_unique value of the Session.
// If the Session object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SessionMutation) OldIsUnique(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsUnique is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsUnique requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsUnique: %w", err)
	}
	return oldValue.IsUnique, nil
}

// ResetIsUnique reset all changes of the "is_unique" field.
func (m *SessionMutation) ResetIsUnique() {
	m.is_unique = nil
}

// SetIsBounce sets the is_bounce field.
func (m *SessionMutation) SetIsBounce(b bool) {
	m.is_bounce = &b
}

// IsBounce returns the is_bounce value in the mutation.
func (m *SessionMutation) IsBounce() (r bool, exists bool) {
	v := m.is_bounce
	if v == nil {
		return
	}
	return *v, true
}

// OldIsBounce returns the old is_bounce value of the Session.
// If the Session object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SessionMutation) OldIsBounce(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsBounce is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsBounce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsBounce: %w", err)
	}
	return oldValue.IsBounce, nil
}

// ResetIsBounce reset all changes of the "is_bounce" field.
func (m *SessionMutation) ResetIsBounce() {
	m.is_bounce = nil
}

// SetIsFinished sets the is_finished field.
func (m *SessionMutation) SetIsFinished(b bool) {
	m.is_finished = &b
}

// IsFinished returns the is_finished value in the mutation.
func (m *SessionMutation) IsFinished() (r bool, exists bool) {
	v := m.is_finished
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFinished returns the old is_finished value of the Session.
// If the Session object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SessionMutation) OldIsFinished(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsFinished is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsFinished requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFinished: %w", err)
	}
	return oldValue.IsFinished, nil
}

// ResetIsFinished reset all changes of the "is_finished" field.
func (m *SessionMutation) ResetIsFinished() {
	m.is_finished = nil
}

// SetDuration sets the duration field.
func (m *SessionMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the duration value in the mutation.
func (m *SessionMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old duration value of the Session.
// If the Session object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SessionMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDuration is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to duration.
func (m *SessionMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the duration field in this mutation.
func (m *SessionMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ClearDuration clears the value of duration.
func (m *SessionMutation) ClearDuration() {
	m.duration = nil
	m.addduration = nil
	m.clearedFields[session.FieldDuration] = struct{}{}
}

// DurationCleared returns if the field duration was cleared in this mutation.
func (m *SessionMutation) DurationCleared() bool {
	_, ok := m.clearedFields[session.FieldDuration]
	return ok
}

// ResetDuration reset all changes of the "duration" field.
func (m *SessionMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
	delete(m.clearedFields, session.FieldDuration)
}

// SetStartedAt sets the started_at field.
func (m *SessionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the started_at value in the mutation.
func (m *SessionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old started_at value of the Session.
// If the Session object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SessionMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt reset all changes of the "started_at" field.
func (m *SessionMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetFinishedAt sets the finished_at field.
func (m *SessionMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the finished_at value in the mutation.
func (m *SessionMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old finished_at value of the Session.
// If the Session object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SessionMutation) OldFinishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFinishedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of finished_at.
func (m *SessionMutation) ClearFinishedAt() {
	m.finished_at = nil
	m.clearedFields[session.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the field finished_at was cleared in this mutation.
func (m *SessionMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[session.FieldFinishedAt]
	return ok
}

// ResetFinishedAt reset all changes of the "finished_at" field.
func (m *SessionMutation) ResetFinishedAt() {
	m.finished_at = nil
	delete(m.clearedFields, session.FieldFinishedAt)
}

// SetAppID sets the app edge to App by id.
func (m *SessionMutation) SetAppID(id int) {
	m.app = &id
}

// ClearApp clears the app edge to App.
func (m *SessionMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared returns if the edge app was cleared.
func (m *SessionMutation) AppCleared() bool {
	return m.clearedapp
}

// AppID returns the app id in the mutation.
func (m *SessionMutation) AppID() (id int, exists bool) {
	if m.app != nil {
		return *m.app, true
	}
	return
}

// AppIDs returns the app ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp reset all changes of the "app" edge.
func (m *SessionMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// SetUserID sets the user edge to User by id.
func (m *SessionMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the user edge to User.
func (m *SessionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *SessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the user id in the mutation.
func (m *SessionMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the user ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *SessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetDeviceID sets the device edge to Device by id.
func (m *SessionMutation) SetDeviceID(id string) {
	m.device = &id
}

// ClearDevice clears the device edge to Device.
func (m *SessionMutation) ClearDevice() {
	m.cleareddevice = true
}

// DeviceCleared returns if the edge device was cleared.
func (m *SessionMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceID returns the device id in the mutation.
func (m *SessionMutation) DeviceID() (id string, exists bool) {
	if m.device != nil {
		return *m.device, true
	}
	return
}

// DeviceIDs returns the device ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) DeviceIDs() (ids []string) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice reset all changes of the "device" edge.
func (m *SessionMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// AddPageviewIDs adds the pageviews edge to PageView by ids.
func (m *SessionMutation) AddPageviewIDs(ids ...uuid.UUID) {
	if m.pageviews == nil {
		m.pageviews = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.pageviews[ids[i]] = struct{}{}
	}
}

// RemovePageviewIDs removes the pageviews edge to PageView by ids.
func (m *SessionMutation) RemovePageviewIDs(ids ...uuid.UUID) {
	if m.removedpageviews == nil {
		m.removedpageviews = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removedpageviews[ids[i]] = struct{}{}
	}
}

// RemovedPageviews returns the removed ids of pageviews.
func (m *SessionMutation) RemovedPageviewsIDs() (ids []uuid.UUID) {
	for id := range m.removedpageviews {
		ids = append(ids, id)
	}
	return
}

// PageviewsIDs returns the pageviews ids in the mutation.
func (m *SessionMutation) PageviewsIDs() (ids []uuid.UUID) {
	for id := range m.pageviews {
		ids = append(ids, id)
	}
	return
}

// ResetPageviews reset all changes of the "pageviews" edge.
func (m *SessionMutation) ResetPageviews() {
	m.pageviews = nil
	m.removedpageviews = nil
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.new_user != nil {
		fields = append(fields, session.FieldNewUser)
	}
	if m.is_unique != nil {
		fields = append(fields, session.FieldIsUnique)
	}
	if m.is_bounce != nil {
		fields = append(fields, session.FieldIsBounce)
	}
	if m.is_finished != nil {
		fields = append(fields, session.FieldIsFinished)
	}
	if m.duration != nil {
		fields = append(fields, session.FieldDuration)
	}
	if m.started_at != nil {
		fields = append(fields, session.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, session.FieldFinishedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldNewUser:
		return m.NewUser()
	case session.FieldIsUnique:
		return m.IsUnique()
	case session.FieldIsBounce:
		return m.IsBounce()
	case session.FieldIsFinished:
		return m.IsFinished()
	case session.FieldDuration:
		return m.Duration()
	case session.FieldStartedAt:
		return m.StartedAt()
	case session.FieldFinishedAt:
		return m.FinishedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldNewUser:
		return m.OldNewUser(ctx)
	case session.FieldIsUnique:
		return m.OldIsUnique(ctx)
	case session.FieldIsBounce:
		return m.OldIsBounce(ctx)
	case session.FieldIsFinished:
		return m.OldIsFinished(ctx)
	case session.FieldDuration:
		return m.OldDuration(ctx)
	case session.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case session.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldNewUser:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNewUser(v)
		return nil
	case session.FieldIsUnique:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsUnique(v)
		return nil
	case session.FieldIsBounce:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsBounce(v)
		return nil
	case session.FieldIsFinished:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFinished(v)
		return nil
	case session.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case session.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case session.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SessionMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, session.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case session.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case session.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(session.FieldDuration) {
		fields = append(fields, session.FieldDuration)
	}
	if m.FieldCleared(session.FieldFinishedAt) {
		fields = append(fields, session.FieldFinishedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	switch name {
	case session.FieldDuration:
		m.ClearDuration()
		return nil
	case session.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldNewUser:
		m.ResetNewUser()
		return nil
	case session.FieldIsUnique:
		m.ResetIsUnique()
		return nil
	case session.FieldIsBounce:
		m.ResetIsBounce()
		return nil
	case session.FieldIsFinished:
		m.ResetIsFinished()
		return nil
	case session.FieldDuration:
		m.ResetDuration()
		return nil
	case session.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case session.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.app != nil {
		edges = append(edges, session.EdgeApp)
	}
	if m.user != nil {
		edges = append(edges, session.EdgeUser)
	}
	if m.device != nil {
		edges = append(edges, session.EdgeDevice)
	}
	if m.pageviews != nil {
		edges = append(edges, session.EdgePageviews)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case session.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case session.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	case session.EdgePageviews:
		ids := make([]ent.Value, 0, len(m.pageviews))
		for id := range m.pageviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedpageviews != nil {
		edges = append(edges, session.EdgePageviews)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case session.EdgePageviews:
		ids := make([]ent.Value, 0, len(m.removedpageviews))
		for id := range m.removedpageviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedapp {
		edges = append(edges, session.EdgeApp)
	}
	if m.cleareduser {
		edges = append(edges, session.EdgeUser)
	}
	if m.cleareddevice {
		edges = append(edges, session.EdgeDevice)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeApp:
		return m.clearedapp
	case session.EdgeUser:
		return m.cleareduser
	case session.EdgeDevice:
		return m.cleareddevice
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	case session.EdgeApp:
		m.ClearApp()
		return nil
	case session.EdgeUser:
		m.ClearUser()
		return nil
	case session.EdgeDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeApp:
		m.ResetApp()
		return nil
	case session.EdgeUser:
		m.ResetUser()
		return nil
	case session.EdgeDevice:
		m.ResetDevice()
		return nil
	case session.EdgePageviews:
		m.ResetPageviews()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op              Op
	typ             string
	id              *string
	name            *string
	is_anonymous    *bool
	clearedFields   map[string]struct{}
	sessions        map[uuid.UUID]struct{}
	removedsessions map[uuid.UUID]struct{}
	done            bool
	oldValue        func(context.Context) (*User, error)
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on User creation.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetIsAnonymous sets the is_anonymous field.
func (m *UserMutation) SetIsAnonymous(b bool) {
	m.is_anonymous = &b
}

// IsAnonymous returns the is_anonymous value in the mutation.
func (m *UserMutation) IsAnonymous() (r bool, exists bool) {
	v := m.is_anonymous
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAnonymous returns the old is_anonymous value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldIsAnonymous(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsAnonymous is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsAnonymous requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAnonymous: %w", err)
	}
	return oldValue.IsAnonymous, nil
}

// ResetIsAnonymous reset all changes of the "is_anonymous" field.
func (m *UserMutation) ResetIsAnonymous() {
	m.is_anonymous = nil
}

// AddSessionIDs adds the sessions edge to Session by ids.
func (m *UserMutation) AddSessionIDs(ids ...uuid.UUID) {
	if m.sessions == nil {
		m.sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// RemoveSessionIDs removes the sessions edge to Session by ids.
func (m *UserMutation) RemoveSessionIDs(ids ...uuid.UUID) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed ids of sessions.
func (m *UserMutation) RemovedSessionsIDs() (ids []uuid.UUID) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the sessions ids in the mutation.
func (m *UserMutation) SessionsIDs() (ids []uuid.UUID) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions reset all changes of the "sessions" edge.
func (m *UserMutation) ResetSessions() {
	m.sessions = nil
	m.removedsessions = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.is_anonymous != nil {
		fields = append(fields, user.FieldIsAnonymous)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldIsAnonymous:
		return m.IsAnonymous()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldIsAnonymous:
		return m.OldIsAnonymous(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldIsAnonymous:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAnonymous(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldIsAnonymous:
		m.ResetIsAnonymous()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.sessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeSessions:
		m.ResetSessions()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
