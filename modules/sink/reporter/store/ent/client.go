// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"github.com/blushft/strana/modules/sink/reporter/store/ent/migrate"
	"github.com/google/uuid"

	"github.com/blushft/strana/modules/sink/reporter/store/ent/action"
	"github.com/blushft/strana/modules/sink/reporter/store/ent/alias"
	"github.com/blushft/strana/modules/sink/reporter/store/ent/app"
	"github.com/blushft/strana/modules/sink/reporter/store/ent/browser"
	"github.com/blushft/strana/modules/sink/reporter/store/ent/campaign"
	"github.com/blushft/strana/modules/sink/reporter/store/ent/connectivity"
	"github.com/blushft/strana/modules/sink/reporter/store/ent/device"
	"github.com/blushft/strana/modules/sink/reporter/store/ent/event"
	"github.com/blushft/strana/modules/sink/reporter/store/ent/extra"
	"github.com/blushft/strana/modules/sink/reporter/store/ent/group"
	"github.com/blushft/strana/modules/sink/reporter/store/ent/library"
	"github.com/blushft/strana/modules/sink/reporter/store/ent/location"
	"github.com/blushft/strana/modules/sink/reporter/store/ent/network"
	"github.com/blushft/strana/modules/sink/reporter/store/ent/oscontext"
	"github.com/blushft/strana/modules/sink/reporter/store/ent/page"
	"github.com/blushft/strana/modules/sink/reporter/store/ent/referrer"
	"github.com/blushft/strana/modules/sink/reporter/store/ent/screen"
	"github.com/blushft/strana/modules/sink/reporter/store/ent/session"
	"github.com/blushft/strana/modules/sink/reporter/store/ent/timing"
	"github.com/blushft/strana/modules/sink/reporter/store/ent/user"
	"github.com/blushft/strana/modules/sink/reporter/store/ent/viewport"

	"github.com/facebook/ent/dialect"
	"github.com/facebook/ent/dialect/sql"
	"github.com/facebook/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Action is the client for interacting with the Action builders.
	Action *ActionClient
	// Alias is the client for interacting with the Alias builders.
	Alias *AliasClient
	// App is the client for interacting with the App builders.
	App *AppClient
	// Browser is the client for interacting with the Browser builders.
	Browser *BrowserClient
	// Campaign is the client for interacting with the Campaign builders.
	Campaign *CampaignClient
	// Connectivity is the client for interacting with the Connectivity builders.
	Connectivity *ConnectivityClient
	// Device is the client for interacting with the Device builders.
	Device *DeviceClient
	// Event is the client for interacting with the Event builders.
	Event *EventClient
	// Extra is the client for interacting with the Extra builders.
	Extra *ExtraClient
	// Group is the client for interacting with the Group builders.
	Group *GroupClient
	// Library is the client for interacting with the Library builders.
	Library *LibraryClient
	// Location is the client for interacting with the Location builders.
	Location *LocationClient
	// Network is the client for interacting with the Network builders.
	Network *NetworkClient
	// OSContext is the client for interacting with the OSContext builders.
	OSContext *OSContextClient
	// Page is the client for interacting with the Page builders.
	Page *PageClient
	// Referrer is the client for interacting with the Referrer builders.
	Referrer *ReferrerClient
	// Screen is the client for interacting with the Screen builders.
	Screen *ScreenClient
	// Session is the client for interacting with the Session builders.
	Session *SessionClient
	// Timing is the client for interacting with the Timing builders.
	Timing *TimingClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// Viewport is the client for interacting with the Viewport builders.
	Viewport *ViewportClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Action = NewActionClient(c.config)
	c.Alias = NewAliasClient(c.config)
	c.App = NewAppClient(c.config)
	c.Browser = NewBrowserClient(c.config)
	c.Campaign = NewCampaignClient(c.config)
	c.Connectivity = NewConnectivityClient(c.config)
	c.Device = NewDeviceClient(c.config)
	c.Event = NewEventClient(c.config)
	c.Extra = NewExtraClient(c.config)
	c.Group = NewGroupClient(c.config)
	c.Library = NewLibraryClient(c.config)
	c.Location = NewLocationClient(c.config)
	c.Network = NewNetworkClient(c.config)
	c.OSContext = NewOSContextClient(c.config)
	c.Page = NewPageClient(c.config)
	c.Referrer = NewReferrerClient(c.config)
	c.Screen = NewScreenClient(c.config)
	c.Session = NewSessionClient(c.config)
	c.Timing = NewTimingClient(c.config)
	c.User = NewUserClient(c.config)
	c.Viewport = NewViewportClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: tx, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		ctx:          ctx,
		config:       cfg,
		Action:       NewActionClient(cfg),
		Alias:        NewAliasClient(cfg),
		App:          NewAppClient(cfg),
		Browser:      NewBrowserClient(cfg),
		Campaign:     NewCampaignClient(cfg),
		Connectivity: NewConnectivityClient(cfg),
		Device:       NewDeviceClient(cfg),
		Event:        NewEventClient(cfg),
		Extra:        NewExtraClient(cfg),
		Group:        NewGroupClient(cfg),
		Library:      NewLibraryClient(cfg),
		Location:     NewLocationClient(cfg),
		Network:      NewNetworkClient(cfg),
		OSContext:    NewOSContextClient(cfg),
		Page:         NewPageClient(cfg),
		Referrer:     NewReferrerClient(cfg),
		Screen:       NewScreenClient(cfg),
		Session:      NewSessionClient(cfg),
		Timing:       NewTimingClient(cfg),
		User:         NewUserClient(cfg),
		Viewport:     NewViewportClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(*sql.Driver).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: &txDriver{tx: tx, drv: c.driver}, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		config:       cfg,
		Action:       NewActionClient(cfg),
		Alias:        NewAliasClient(cfg),
		App:          NewAppClient(cfg),
		Browser:      NewBrowserClient(cfg),
		Campaign:     NewCampaignClient(cfg),
		Connectivity: NewConnectivityClient(cfg),
		Device:       NewDeviceClient(cfg),
		Event:        NewEventClient(cfg),
		Extra:        NewExtraClient(cfg),
		Group:        NewGroupClient(cfg),
		Library:      NewLibraryClient(cfg),
		Location:     NewLocationClient(cfg),
		Network:      NewNetworkClient(cfg),
		OSContext:    NewOSContextClient(cfg),
		Page:         NewPageClient(cfg),
		Referrer:     NewReferrerClient(cfg),
		Screen:       NewScreenClient(cfg),
		Session:      NewSessionClient(cfg),
		Timing:       NewTimingClient(cfg),
		User:         NewUserClient(cfg),
		Viewport:     NewViewportClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Action.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := config{driver: dialect.Debug(c.driver, c.log), log: c.log, debug: true, hooks: c.hooks}
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Action.Use(hooks...)
	c.Alias.Use(hooks...)
	c.App.Use(hooks...)
	c.Browser.Use(hooks...)
	c.Campaign.Use(hooks...)
	c.Connectivity.Use(hooks...)
	c.Device.Use(hooks...)
	c.Event.Use(hooks...)
	c.Extra.Use(hooks...)
	c.Group.Use(hooks...)
	c.Library.Use(hooks...)
	c.Location.Use(hooks...)
	c.Network.Use(hooks...)
	c.OSContext.Use(hooks...)
	c.Page.Use(hooks...)
	c.Referrer.Use(hooks...)
	c.Screen.Use(hooks...)
	c.Session.Use(hooks...)
	c.Timing.Use(hooks...)
	c.User.Use(hooks...)
	c.Viewport.Use(hooks...)
}

// ActionClient is a client for the Action schema.
type ActionClient struct {
	config
}

// NewActionClient returns a client for the Action from the given config.
func NewActionClient(c config) *ActionClient {
	return &ActionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `action.Hooks(f(g(h())))`.
func (c *ActionClient) Use(hooks ...Hook) {
	c.hooks.Action = append(c.hooks.Action, hooks...)
}

// Create returns a create builder for Action.
func (c *ActionClient) Create() *ActionCreate {
	mutation := newActionMutation(c.config, OpCreate)
	return &ActionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Action entities.
func (c *ActionClient) CreateBulk(builders ...*ActionCreate) *ActionCreateBulk {
	return &ActionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Action.
func (c *ActionClient) Update() *ActionUpdate {
	mutation := newActionMutation(c.config, OpUpdate)
	return &ActionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ActionClient) UpdateOne(a *Action) *ActionUpdateOne {
	mutation := newActionMutation(c.config, OpUpdateOne, withAction(a))
	return &ActionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ActionClient) UpdateOneID(id int) *ActionUpdateOne {
	mutation := newActionMutation(c.config, OpUpdateOne, withActionID(id))
	return &ActionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Action.
func (c *ActionClient) Delete() *ActionDelete {
	mutation := newActionMutation(c.config, OpDelete)
	return &ActionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ActionClient) DeleteOne(a *Action) *ActionDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ActionClient) DeleteOneID(id int) *ActionDeleteOne {
	builder := c.Delete().Where(action.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ActionDeleteOne{builder}
}

// Query returns a query builder for Action.
func (c *ActionClient) Query() *ActionQuery {
	return &ActionQuery{config: c.config}
}

// Get returns a Action entity by its id.
func (c *ActionClient) Get(ctx context.Context, id int) (*Action, error) {
	return c.Query().Where(action.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ActionClient) GetX(ctx context.Context, id int) *Action {
	a, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return a
}

// QueryEvent queries the event edge of a Action.
func (c *ActionClient) QueryEvent(a *Action) *EventQuery {
	query := &EventQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(action.Table, action.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, action.EventTable, action.EventColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ActionClient) Hooks() []Hook {
	return c.hooks.Action
}

// AliasClient is a client for the Alias schema.
type AliasClient struct {
	config
}

// NewAliasClient returns a client for the Alias from the given config.
func NewAliasClient(c config) *AliasClient {
	return &AliasClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `alias.Hooks(f(g(h())))`.
func (c *AliasClient) Use(hooks ...Hook) {
	c.hooks.Alias = append(c.hooks.Alias, hooks...)
}

// Create returns a create builder for Alias.
func (c *AliasClient) Create() *AliasCreate {
	mutation := newAliasMutation(c.config, OpCreate)
	return &AliasCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Alias entities.
func (c *AliasClient) CreateBulk(builders ...*AliasCreate) *AliasCreateBulk {
	return &AliasCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Alias.
func (c *AliasClient) Update() *AliasUpdate {
	mutation := newAliasMutation(c.config, OpUpdate)
	return &AliasUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AliasClient) UpdateOne(a *Alias) *AliasUpdateOne {
	mutation := newAliasMutation(c.config, OpUpdateOne, withAlias(a))
	return &AliasUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AliasClient) UpdateOneID(id int) *AliasUpdateOne {
	mutation := newAliasMutation(c.config, OpUpdateOne, withAliasID(id))
	return &AliasUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Alias.
func (c *AliasClient) Delete() *AliasDelete {
	mutation := newAliasMutation(c.config, OpDelete)
	return &AliasDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AliasClient) DeleteOne(a *Alias) *AliasDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AliasClient) DeleteOneID(id int) *AliasDeleteOne {
	builder := c.Delete().Where(alias.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AliasDeleteOne{builder}
}

// Query returns a query builder for Alias.
func (c *AliasClient) Query() *AliasQuery {
	return &AliasQuery{config: c.config}
}

// Get returns a Alias entity by its id.
func (c *AliasClient) Get(ctx context.Context, id int) (*Alias, error) {
	return c.Query().Where(alias.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AliasClient) GetX(ctx context.Context, id int) *Alias {
	a, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return a
}

// QueryEvent queries the event edge of a Alias.
func (c *AliasClient) QueryEvent(a *Alias) *EventQuery {
	query := &EventQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(alias.Table, alias.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, alias.EventTable, alias.EventColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Alias.
func (c *AliasClient) QueryUser(a *Alias) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(alias.Table, alias.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, alias.UserTable, alias.UserColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AliasClient) Hooks() []Hook {
	return c.hooks.Alias
}

// AppClient is a client for the App schema.
type AppClient struct {
	config
}

// NewAppClient returns a client for the App from the given config.
func NewAppClient(c config) *AppClient {
	return &AppClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `app.Hooks(f(g(h())))`.
func (c *AppClient) Use(hooks ...Hook) {
	c.hooks.App = append(c.hooks.App, hooks...)
}

// Create returns a create builder for App.
func (c *AppClient) Create() *AppCreate {
	mutation := newAppMutation(c.config, OpCreate)
	return &AppCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of App entities.
func (c *AppClient) CreateBulk(builders ...*AppCreate) *AppCreateBulk {
	return &AppCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for App.
func (c *AppClient) Update() *AppUpdate {
	mutation := newAppMutation(c.config, OpUpdate)
	return &AppUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppClient) UpdateOne(a *App) *AppUpdateOne {
	mutation := newAppMutation(c.config, OpUpdateOne, withApp(a))
	return &AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppClient) UpdateOneID(id int) *AppUpdateOne {
	mutation := newAppMutation(c.config, OpUpdateOne, withAppID(id))
	return &AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for App.
func (c *AppClient) Delete() *AppDelete {
	mutation := newAppMutation(c.config, OpDelete)
	return &AppDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AppClient) DeleteOne(a *App) *AppDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AppClient) DeleteOneID(id int) *AppDeleteOne {
	builder := c.Delete().Where(app.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppDeleteOne{builder}
}

// Query returns a query builder for App.
func (c *AppClient) Query() *AppQuery {
	return &AppQuery{config: c.config}
}

// Get returns a App entity by its id.
func (c *AppClient) Get(ctx context.Context, id int) (*App, error) {
	return c.Query().Where(app.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppClient) GetX(ctx context.Context, id int) *App {
	a, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return a
}

// QueryEvents queries the events edge of a App.
func (c *AppClient) QueryEvents(a *App) *EventQuery {
	query := &EventQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, app.EventsTable, app.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AppClient) Hooks() []Hook {
	return c.hooks.App
}

// BrowserClient is a client for the Browser schema.
type BrowserClient struct {
	config
}

// NewBrowserClient returns a client for the Browser from the given config.
func NewBrowserClient(c config) *BrowserClient {
	return &BrowserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `browser.Hooks(f(g(h())))`.
func (c *BrowserClient) Use(hooks ...Hook) {
	c.hooks.Browser = append(c.hooks.Browser, hooks...)
}

// Create returns a create builder for Browser.
func (c *BrowserClient) Create() *BrowserCreate {
	mutation := newBrowserMutation(c.config, OpCreate)
	return &BrowserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Browser entities.
func (c *BrowserClient) CreateBulk(builders ...*BrowserCreate) *BrowserCreateBulk {
	return &BrowserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Browser.
func (c *BrowserClient) Update() *BrowserUpdate {
	mutation := newBrowserMutation(c.config, OpUpdate)
	return &BrowserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BrowserClient) UpdateOne(b *Browser) *BrowserUpdateOne {
	mutation := newBrowserMutation(c.config, OpUpdateOne, withBrowser(b))
	return &BrowserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BrowserClient) UpdateOneID(id int) *BrowserUpdateOne {
	mutation := newBrowserMutation(c.config, OpUpdateOne, withBrowserID(id))
	return &BrowserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Browser.
func (c *BrowserClient) Delete() *BrowserDelete {
	mutation := newBrowserMutation(c.config, OpDelete)
	return &BrowserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *BrowserClient) DeleteOne(b *Browser) *BrowserDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *BrowserClient) DeleteOneID(id int) *BrowserDeleteOne {
	builder := c.Delete().Where(browser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BrowserDeleteOne{builder}
}

// Query returns a query builder for Browser.
func (c *BrowserClient) Query() *BrowserQuery {
	return &BrowserQuery{config: c.config}
}

// Get returns a Browser entity by its id.
func (c *BrowserClient) Get(ctx context.Context, id int) (*Browser, error) {
	return c.Query().Where(browser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BrowserClient) GetX(ctx context.Context, id int) *Browser {
	b, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return b
}

// QueryEvent queries the event edge of a Browser.
func (c *BrowserClient) QueryEvent(b *Browser) *EventQuery {
	query := &EventQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(browser.Table, browser.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, browser.EventTable, browser.EventColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BrowserClient) Hooks() []Hook {
	return c.hooks.Browser
}

// CampaignClient is a client for the Campaign schema.
type CampaignClient struct {
	config
}

// NewCampaignClient returns a client for the Campaign from the given config.
func NewCampaignClient(c config) *CampaignClient {
	return &CampaignClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `campaign.Hooks(f(g(h())))`.
func (c *CampaignClient) Use(hooks ...Hook) {
	c.hooks.Campaign = append(c.hooks.Campaign, hooks...)
}

// Create returns a create builder for Campaign.
func (c *CampaignClient) Create() *CampaignCreate {
	mutation := newCampaignMutation(c.config, OpCreate)
	return &CampaignCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Campaign entities.
func (c *CampaignClient) CreateBulk(builders ...*CampaignCreate) *CampaignCreateBulk {
	return &CampaignCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Campaign.
func (c *CampaignClient) Update() *CampaignUpdate {
	mutation := newCampaignMutation(c.config, OpUpdate)
	return &CampaignUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CampaignClient) UpdateOne(ca *Campaign) *CampaignUpdateOne {
	mutation := newCampaignMutation(c.config, OpUpdateOne, withCampaign(ca))
	return &CampaignUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CampaignClient) UpdateOneID(id int) *CampaignUpdateOne {
	mutation := newCampaignMutation(c.config, OpUpdateOne, withCampaignID(id))
	return &CampaignUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Campaign.
func (c *CampaignClient) Delete() *CampaignDelete {
	mutation := newCampaignMutation(c.config, OpDelete)
	return &CampaignDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *CampaignClient) DeleteOne(ca *Campaign) *CampaignDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *CampaignClient) DeleteOneID(id int) *CampaignDeleteOne {
	builder := c.Delete().Where(campaign.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CampaignDeleteOne{builder}
}

// Query returns a query builder for Campaign.
func (c *CampaignClient) Query() *CampaignQuery {
	return &CampaignQuery{config: c.config}
}

// Get returns a Campaign entity by its id.
func (c *CampaignClient) Get(ctx context.Context, id int) (*Campaign, error) {
	return c.Query().Where(campaign.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CampaignClient) GetX(ctx context.Context, id int) *Campaign {
	ca, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return ca
}

// QueryEvent queries the event edge of a Campaign.
func (c *CampaignClient) QueryEvent(ca *Campaign) *EventQuery {
	query := &EventQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(campaign.Table, campaign.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, campaign.EventTable, campaign.EventColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CampaignClient) Hooks() []Hook {
	return c.hooks.Campaign
}

// ConnectivityClient is a client for the Connectivity schema.
type ConnectivityClient struct {
	config
}

// NewConnectivityClient returns a client for the Connectivity from the given config.
func NewConnectivityClient(c config) *ConnectivityClient {
	return &ConnectivityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `connectivity.Hooks(f(g(h())))`.
func (c *ConnectivityClient) Use(hooks ...Hook) {
	c.hooks.Connectivity = append(c.hooks.Connectivity, hooks...)
}

// Create returns a create builder for Connectivity.
func (c *ConnectivityClient) Create() *ConnectivityCreate {
	mutation := newConnectivityMutation(c.config, OpCreate)
	return &ConnectivityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Connectivity entities.
func (c *ConnectivityClient) CreateBulk(builders ...*ConnectivityCreate) *ConnectivityCreateBulk {
	return &ConnectivityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Connectivity.
func (c *ConnectivityClient) Update() *ConnectivityUpdate {
	mutation := newConnectivityMutation(c.config, OpUpdate)
	return &ConnectivityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ConnectivityClient) UpdateOne(co *Connectivity) *ConnectivityUpdateOne {
	mutation := newConnectivityMutation(c.config, OpUpdateOne, withConnectivity(co))
	return &ConnectivityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ConnectivityClient) UpdateOneID(id int) *ConnectivityUpdateOne {
	mutation := newConnectivityMutation(c.config, OpUpdateOne, withConnectivityID(id))
	return &ConnectivityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Connectivity.
func (c *ConnectivityClient) Delete() *ConnectivityDelete {
	mutation := newConnectivityMutation(c.config, OpDelete)
	return &ConnectivityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ConnectivityClient) DeleteOne(co *Connectivity) *ConnectivityDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ConnectivityClient) DeleteOneID(id int) *ConnectivityDeleteOne {
	builder := c.Delete().Where(connectivity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ConnectivityDeleteOne{builder}
}

// Query returns a query builder for Connectivity.
func (c *ConnectivityClient) Query() *ConnectivityQuery {
	return &ConnectivityQuery{config: c.config}
}

// Get returns a Connectivity entity by its id.
func (c *ConnectivityClient) Get(ctx context.Context, id int) (*Connectivity, error) {
	return c.Query().Where(connectivity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ConnectivityClient) GetX(ctx context.Context, id int) *Connectivity {
	co, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return co
}

// QueryEvent queries the event edge of a Connectivity.
func (c *ConnectivityClient) QueryEvent(co *Connectivity) *EventQuery {
	query := &EventQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(connectivity.Table, connectivity.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, connectivity.EventTable, connectivity.EventColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ConnectivityClient) Hooks() []Hook {
	return c.hooks.Connectivity
}

// DeviceClient is a client for the Device schema.
type DeviceClient struct {
	config
}

// NewDeviceClient returns a client for the Device from the given config.
func NewDeviceClient(c config) *DeviceClient {
	return &DeviceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `device.Hooks(f(g(h())))`.
func (c *DeviceClient) Use(hooks ...Hook) {
	c.hooks.Device = append(c.hooks.Device, hooks...)
}

// Create returns a create builder for Device.
func (c *DeviceClient) Create() *DeviceCreate {
	mutation := newDeviceMutation(c.config, OpCreate)
	return &DeviceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Device entities.
func (c *DeviceClient) CreateBulk(builders ...*DeviceCreate) *DeviceCreateBulk {
	return &DeviceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Device.
func (c *DeviceClient) Update() *DeviceUpdate {
	mutation := newDeviceMutation(c.config, OpUpdate)
	return &DeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeviceClient) UpdateOne(d *Device) *DeviceUpdateOne {
	mutation := newDeviceMutation(c.config, OpUpdateOne, withDevice(d))
	return &DeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DeviceClient) UpdateOneID(id string) *DeviceUpdateOne {
	mutation := newDeviceMutation(c.config, OpUpdateOne, withDeviceID(id))
	return &DeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Device.
func (c *DeviceClient) Delete() *DeviceDelete {
	mutation := newDeviceMutation(c.config, OpDelete)
	return &DeviceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *DeviceClient) DeleteOne(d *Device) *DeviceDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *DeviceClient) DeleteOneID(id string) *DeviceDeleteOne {
	builder := c.Delete().Where(device.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeviceDeleteOne{builder}
}

// Query returns a query builder for Device.
func (c *DeviceClient) Query() *DeviceQuery {
	return &DeviceQuery{config: c.config}
}

// Get returns a Device entity by its id.
func (c *DeviceClient) Get(ctx context.Context, id string) (*Device, error) {
	return c.Query().Where(device.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeviceClient) GetX(ctx context.Context, id string) *Device {
	d, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return d
}

// QueryEvents queries the events edge of a Device.
func (c *DeviceClient) QueryEvents(d *Device) *EventQuery {
	query := &EventQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(device.Table, device.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, device.EventsTable, device.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DeviceClient) Hooks() []Hook {
	return c.hooks.Device
}

// EventClient is a client for the Event schema.
type EventClient struct {
	config
}

// NewEventClient returns a client for the Event from the given config.
func NewEventClient(c config) *EventClient {
	return &EventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `event.Hooks(f(g(h())))`.
func (c *EventClient) Use(hooks ...Hook) {
	c.hooks.Event = append(c.hooks.Event, hooks...)
}

// Create returns a create builder for Event.
func (c *EventClient) Create() *EventCreate {
	mutation := newEventMutation(c.config, OpCreate)
	return &EventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Event entities.
func (c *EventClient) CreateBulk(builders ...*EventCreate) *EventCreateBulk {
	return &EventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Event.
func (c *EventClient) Update() *EventUpdate {
	mutation := newEventMutation(c.config, OpUpdate)
	return &EventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventClient) UpdateOne(e *Event) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEvent(e))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventClient) UpdateOneID(id uuid.UUID) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEventID(id))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Event.
func (c *EventClient) Delete() *EventDelete {
	mutation := newEventMutation(c.config, OpDelete)
	return &EventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *EventClient) DeleteOne(e *Event) *EventDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *EventClient) DeleteOneID(id uuid.UUID) *EventDeleteOne {
	builder := c.Delete().Where(event.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventDeleteOne{builder}
}

// Query returns a query builder for Event.
func (c *EventClient) Query() *EventQuery {
	return &EventQuery{config: c.config}
}

// Get returns a Event entity by its id.
func (c *EventClient) Get(ctx context.Context, id uuid.UUID) (*Event, error) {
	return c.Query().Where(event.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventClient) GetX(ctx context.Context, id uuid.UUID) *Event {
	e, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return e
}

// QueryAction queries the action edge of a Event.
func (c *EventClient) QueryAction(e *Event) *ActionQuery {
	query := &ActionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(action.Table, action.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, event.ActionTable, event.ActionColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAlias queries the alias edge of a Event.
func (c *EventClient) QueryAlias(e *Event) *AliasQuery {
	query := &AliasQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(alias.Table, alias.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, event.AliasTable, event.AliasColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApp queries the app edge of a Event.
func (c *EventClient) QueryApp(e *Event) *AppQuery {
	query := &AppQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, event.AppTable, event.AppColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBrowser queries the browser edge of a Event.
func (c *EventClient) QueryBrowser(e *Event) *BrowserQuery {
	query := &BrowserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(browser.Table, browser.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, event.BrowserTable, event.BrowserColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCampaign queries the campaign edge of a Event.
func (c *EventClient) QueryCampaign(e *Event) *CampaignQuery {
	query := &CampaignQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(campaign.Table, campaign.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, event.CampaignTable, event.CampaignColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConnectivity queries the connectivity edge of a Event.
func (c *EventClient) QueryConnectivity(e *Event) *ConnectivityQuery {
	query := &ConnectivityQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(connectivity.Table, connectivity.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, event.ConnectivityTable, event.ConnectivityColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDevice queries the device edge of a Event.
func (c *EventClient) QueryDevice(e *Event) *DeviceQuery {
	query := &DeviceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(device.Table, device.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, event.DeviceTable, event.DeviceColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExtra queries the extra edge of a Event.
func (c *EventClient) QueryExtra(e *Event) *ExtraQuery {
	query := &ExtraQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(extra.Table, extra.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, event.ExtraTable, event.ExtraColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroup queries the group edge of a Event.
func (c *EventClient) QueryGroup(e *Event) *GroupQuery {
	query := &GroupQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, event.GroupTable, event.GroupColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLibrary queries the library edge of a Event.
func (c *EventClient) QueryLibrary(e *Event) *LibraryQuery {
	query := &LibraryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(library.Table, library.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, event.LibraryTable, event.LibraryColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLocation queries the location edge of a Event.
func (c *EventClient) QueryLocation(e *Event) *LocationQuery {
	query := &LocationQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(location.Table, location.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, event.LocationTable, event.LocationColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNetwork queries the network edge of a Event.
func (c *EventClient) QueryNetwork(e *Event) *NetworkQuery {
	query := &NetworkQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(network.Table, network.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, event.NetworkTable, event.NetworkColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOs queries the os edge of a Event.
func (c *EventClient) QueryOs(e *Event) *OSContextQuery {
	query := &OSContextQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(oscontext.Table, oscontext.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, event.OsTable, event.OsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPage queries the page edge of a Event.
func (c *EventClient) QueryPage(e *Event) *PageQuery {
	query := &PageQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(page.Table, page.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, event.PageTable, event.PageColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReferrer queries the referrer edge of a Event.
func (c *EventClient) QueryReferrer(e *Event) *ReferrerQuery {
	query := &ReferrerQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(referrer.Table, referrer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, event.ReferrerTable, event.ReferrerColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScreen queries the screen edge of a Event.
func (c *EventClient) QueryScreen(e *Event) *ScreenQuery {
	query := &ScreenQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(screen.Table, screen.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, event.ScreenTable, event.ScreenColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySession queries the session edge of a Event.
func (c *EventClient) QuerySession(e *Event) *SessionQuery {
	query := &SessionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(session.Table, session.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, event.SessionTable, event.SessionColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTiming queries the timing edge of a Event.
func (c *EventClient) QueryTiming(e *Event) *TimingQuery {
	query := &TimingQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(timing.Table, timing.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, event.TimingTable, event.TimingColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryViewport queries the viewport edge of a Event.
func (c *EventClient) QueryViewport(e *Event) *ViewportQuery {
	query := &ViewportQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(viewport.Table, viewport.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, event.ViewportTable, event.ViewportColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Event.
func (c *EventClient) QueryUser(e *Event) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, event.UserTable, event.UserColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EventClient) Hooks() []Hook {
	return c.hooks.Event
}

// ExtraClient is a client for the Extra schema.
type ExtraClient struct {
	config
}

// NewExtraClient returns a client for the Extra from the given config.
func NewExtraClient(c config) *ExtraClient {
	return &ExtraClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `extra.Hooks(f(g(h())))`.
func (c *ExtraClient) Use(hooks ...Hook) {
	c.hooks.Extra = append(c.hooks.Extra, hooks...)
}

// Create returns a create builder for Extra.
func (c *ExtraClient) Create() *ExtraCreate {
	mutation := newExtraMutation(c.config, OpCreate)
	return &ExtraCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Extra entities.
func (c *ExtraClient) CreateBulk(builders ...*ExtraCreate) *ExtraCreateBulk {
	return &ExtraCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Extra.
func (c *ExtraClient) Update() *ExtraUpdate {
	mutation := newExtraMutation(c.config, OpUpdate)
	return &ExtraUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExtraClient) UpdateOne(e *Extra) *ExtraUpdateOne {
	mutation := newExtraMutation(c.config, OpUpdateOne, withExtra(e))
	return &ExtraUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExtraClient) UpdateOneID(id int) *ExtraUpdateOne {
	mutation := newExtraMutation(c.config, OpUpdateOne, withExtraID(id))
	return &ExtraUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Extra.
func (c *ExtraClient) Delete() *ExtraDelete {
	mutation := newExtraMutation(c.config, OpDelete)
	return &ExtraDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ExtraClient) DeleteOne(e *Extra) *ExtraDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ExtraClient) DeleteOneID(id int) *ExtraDeleteOne {
	builder := c.Delete().Where(extra.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExtraDeleteOne{builder}
}

// Query returns a query builder for Extra.
func (c *ExtraClient) Query() *ExtraQuery {
	return &ExtraQuery{config: c.config}
}

// Get returns a Extra entity by its id.
func (c *ExtraClient) Get(ctx context.Context, id int) (*Extra, error) {
	return c.Query().Where(extra.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExtraClient) GetX(ctx context.Context, id int) *Extra {
	e, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return e
}

// QueryEvent queries the event edge of a Extra.
func (c *ExtraClient) QueryEvent(e *Extra) *EventQuery {
	query := &EventQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(extra.Table, extra.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, extra.EventTable, extra.EventColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ExtraClient) Hooks() []Hook {
	return c.hooks.Extra
}

// GroupClient is a client for the Group schema.
type GroupClient struct {
	config
}

// NewGroupClient returns a client for the Group from the given config.
func NewGroupClient(c config) *GroupClient {
	return &GroupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `group.Hooks(f(g(h())))`.
func (c *GroupClient) Use(hooks ...Hook) {
	c.hooks.Group = append(c.hooks.Group, hooks...)
}

// Create returns a create builder for Group.
func (c *GroupClient) Create() *GroupCreate {
	mutation := newGroupMutation(c.config, OpCreate)
	return &GroupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Group entities.
func (c *GroupClient) CreateBulk(builders ...*GroupCreate) *GroupCreateBulk {
	return &GroupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Group.
func (c *GroupClient) Update() *GroupUpdate {
	mutation := newGroupMutation(c.config, OpUpdate)
	return &GroupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GroupClient) UpdateOne(gr *Group) *GroupUpdateOne {
	mutation := newGroupMutation(c.config, OpUpdateOne, withGroup(gr))
	return &GroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GroupClient) UpdateOneID(id int) *GroupUpdateOne {
	mutation := newGroupMutation(c.config, OpUpdateOne, withGroupID(id))
	return &GroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Group.
func (c *GroupClient) Delete() *GroupDelete {
	mutation := newGroupMutation(c.config, OpDelete)
	return &GroupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *GroupClient) DeleteOne(gr *Group) *GroupDeleteOne {
	return c.DeleteOneID(gr.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *GroupClient) DeleteOneID(id int) *GroupDeleteOne {
	builder := c.Delete().Where(group.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GroupDeleteOne{builder}
}

// Query returns a query builder for Group.
func (c *GroupClient) Query() *GroupQuery {
	return &GroupQuery{config: c.config}
}

// Get returns a Group entity by its id.
func (c *GroupClient) Get(ctx context.Context, id int) (*Group, error) {
	return c.Query().Where(group.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GroupClient) GetX(ctx context.Context, id int) *Group {
	gr, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return gr
}

// QueryEvents queries the events edge of a Group.
func (c *GroupClient) QueryEvents(gr *Group) *EventQuery {
	query := &EventQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := gr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, group.EventsTable, group.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(gr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsers queries the users edge of a Group.
func (c *GroupClient) QueryUsers(gr *Group) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := gr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, group.UsersTable, group.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(gr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GroupClient) Hooks() []Hook {
	return c.hooks.Group
}

// LibraryClient is a client for the Library schema.
type LibraryClient struct {
	config
}

// NewLibraryClient returns a client for the Library from the given config.
func NewLibraryClient(c config) *LibraryClient {
	return &LibraryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `library.Hooks(f(g(h())))`.
func (c *LibraryClient) Use(hooks ...Hook) {
	c.hooks.Library = append(c.hooks.Library, hooks...)
}

// Create returns a create builder for Library.
func (c *LibraryClient) Create() *LibraryCreate {
	mutation := newLibraryMutation(c.config, OpCreate)
	return &LibraryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Library entities.
func (c *LibraryClient) CreateBulk(builders ...*LibraryCreate) *LibraryCreateBulk {
	return &LibraryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Library.
func (c *LibraryClient) Update() *LibraryUpdate {
	mutation := newLibraryMutation(c.config, OpUpdate)
	return &LibraryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LibraryClient) UpdateOne(l *Library) *LibraryUpdateOne {
	mutation := newLibraryMutation(c.config, OpUpdateOne, withLibrary(l))
	return &LibraryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LibraryClient) UpdateOneID(id int) *LibraryUpdateOne {
	mutation := newLibraryMutation(c.config, OpUpdateOne, withLibraryID(id))
	return &LibraryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Library.
func (c *LibraryClient) Delete() *LibraryDelete {
	mutation := newLibraryMutation(c.config, OpDelete)
	return &LibraryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *LibraryClient) DeleteOne(l *Library) *LibraryDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *LibraryClient) DeleteOneID(id int) *LibraryDeleteOne {
	builder := c.Delete().Where(library.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LibraryDeleteOne{builder}
}

// Query returns a query builder for Library.
func (c *LibraryClient) Query() *LibraryQuery {
	return &LibraryQuery{config: c.config}
}

// Get returns a Library entity by its id.
func (c *LibraryClient) Get(ctx context.Context, id int) (*Library, error) {
	return c.Query().Where(library.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LibraryClient) GetX(ctx context.Context, id int) *Library {
	l, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return l
}

// QueryEvents queries the events edge of a Library.
func (c *LibraryClient) QueryEvents(l *Library) *EventQuery {
	query := &EventQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(library.Table, library.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, library.EventsTable, library.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LibraryClient) Hooks() []Hook {
	return c.hooks.Library
}

// LocationClient is a client for the Location schema.
type LocationClient struct {
	config
}

// NewLocationClient returns a client for the Location from the given config.
func NewLocationClient(c config) *LocationClient {
	return &LocationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `location.Hooks(f(g(h())))`.
func (c *LocationClient) Use(hooks ...Hook) {
	c.hooks.Location = append(c.hooks.Location, hooks...)
}

// Create returns a create builder for Location.
func (c *LocationClient) Create() *LocationCreate {
	mutation := newLocationMutation(c.config, OpCreate)
	return &LocationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Location entities.
func (c *LocationClient) CreateBulk(builders ...*LocationCreate) *LocationCreateBulk {
	return &LocationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Location.
func (c *LocationClient) Update() *LocationUpdate {
	mutation := newLocationMutation(c.config, OpUpdate)
	return &LocationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LocationClient) UpdateOne(l *Location) *LocationUpdateOne {
	mutation := newLocationMutation(c.config, OpUpdateOne, withLocation(l))
	return &LocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LocationClient) UpdateOneID(id int) *LocationUpdateOne {
	mutation := newLocationMutation(c.config, OpUpdateOne, withLocationID(id))
	return &LocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Location.
func (c *LocationClient) Delete() *LocationDelete {
	mutation := newLocationMutation(c.config, OpDelete)
	return &LocationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *LocationClient) DeleteOne(l *Location) *LocationDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *LocationClient) DeleteOneID(id int) *LocationDeleteOne {
	builder := c.Delete().Where(location.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LocationDeleteOne{builder}
}

// Query returns a query builder for Location.
func (c *LocationClient) Query() *LocationQuery {
	return &LocationQuery{config: c.config}
}

// Get returns a Location entity by its id.
func (c *LocationClient) Get(ctx context.Context, id int) (*Location, error) {
	return c.Query().Where(location.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LocationClient) GetX(ctx context.Context, id int) *Location {
	l, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return l
}

// QueryEvents queries the events edge of a Location.
func (c *LocationClient) QueryEvents(l *Location) *EventQuery {
	query := &EventQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(location.Table, location.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, location.EventsTable, location.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LocationClient) Hooks() []Hook {
	return c.hooks.Location
}

// NetworkClient is a client for the Network schema.
type NetworkClient struct {
	config
}

// NewNetworkClient returns a client for the Network from the given config.
func NewNetworkClient(c config) *NetworkClient {
	return &NetworkClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `network.Hooks(f(g(h())))`.
func (c *NetworkClient) Use(hooks ...Hook) {
	c.hooks.Network = append(c.hooks.Network, hooks...)
}

// Create returns a create builder for Network.
func (c *NetworkClient) Create() *NetworkCreate {
	mutation := newNetworkMutation(c.config, OpCreate)
	return &NetworkCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Network entities.
func (c *NetworkClient) CreateBulk(builders ...*NetworkCreate) *NetworkCreateBulk {
	return &NetworkCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Network.
func (c *NetworkClient) Update() *NetworkUpdate {
	mutation := newNetworkMutation(c.config, OpUpdate)
	return &NetworkUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NetworkClient) UpdateOne(n *Network) *NetworkUpdateOne {
	mutation := newNetworkMutation(c.config, OpUpdateOne, withNetwork(n))
	return &NetworkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NetworkClient) UpdateOneID(id int) *NetworkUpdateOne {
	mutation := newNetworkMutation(c.config, OpUpdateOne, withNetworkID(id))
	return &NetworkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Network.
func (c *NetworkClient) Delete() *NetworkDelete {
	mutation := newNetworkMutation(c.config, OpDelete)
	return &NetworkDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *NetworkClient) DeleteOne(n *Network) *NetworkDeleteOne {
	return c.DeleteOneID(n.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *NetworkClient) DeleteOneID(id int) *NetworkDeleteOne {
	builder := c.Delete().Where(network.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NetworkDeleteOne{builder}
}

// Query returns a query builder for Network.
func (c *NetworkClient) Query() *NetworkQuery {
	return &NetworkQuery{config: c.config}
}

// Get returns a Network entity by its id.
func (c *NetworkClient) Get(ctx context.Context, id int) (*Network, error) {
	return c.Query().Where(network.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NetworkClient) GetX(ctx context.Context, id int) *Network {
	n, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return n
}

// QueryEvents queries the events edge of a Network.
func (c *NetworkClient) QueryEvents(n *Network) *EventQuery {
	query := &EventQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(network.Table, network.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, network.EventsTable, network.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NetworkClient) Hooks() []Hook {
	return c.hooks.Network
}

// OSContextClient is a client for the OSContext schema.
type OSContextClient struct {
	config
}

// NewOSContextClient returns a client for the OSContext from the given config.
func NewOSContextClient(c config) *OSContextClient {
	return &OSContextClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oscontext.Hooks(f(g(h())))`.
func (c *OSContextClient) Use(hooks ...Hook) {
	c.hooks.OSContext = append(c.hooks.OSContext, hooks...)
}

// Create returns a create builder for OSContext.
func (c *OSContextClient) Create() *OSContextCreate {
	mutation := newOSContextMutation(c.config, OpCreate)
	return &OSContextCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of OSContext entities.
func (c *OSContextClient) CreateBulk(builders ...*OSContextCreate) *OSContextCreateBulk {
	return &OSContextCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OSContext.
func (c *OSContextClient) Update() *OSContextUpdate {
	mutation := newOSContextMutation(c.config, OpUpdate)
	return &OSContextUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OSContextClient) UpdateOne(oc *OSContext) *OSContextUpdateOne {
	mutation := newOSContextMutation(c.config, OpUpdateOne, withOSContext(oc))
	return &OSContextUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OSContextClient) UpdateOneID(id int) *OSContextUpdateOne {
	mutation := newOSContextMutation(c.config, OpUpdateOne, withOSContextID(id))
	return &OSContextUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OSContext.
func (c *OSContextClient) Delete() *OSContextDelete {
	mutation := newOSContextMutation(c.config, OpDelete)
	return &OSContextDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *OSContextClient) DeleteOne(oc *OSContext) *OSContextDeleteOne {
	return c.DeleteOneID(oc.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *OSContextClient) DeleteOneID(id int) *OSContextDeleteOne {
	builder := c.Delete().Where(oscontext.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OSContextDeleteOne{builder}
}

// Query returns a query builder for OSContext.
func (c *OSContextClient) Query() *OSContextQuery {
	return &OSContextQuery{config: c.config}
}

// Get returns a OSContext entity by its id.
func (c *OSContextClient) Get(ctx context.Context, id int) (*OSContext, error) {
	return c.Query().Where(oscontext.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OSContextClient) GetX(ctx context.Context, id int) *OSContext {
	oc, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return oc
}

// QueryEvents queries the events edge of a OSContext.
func (c *OSContextClient) QueryEvents(oc *OSContext) *EventQuery {
	query := &EventQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := oc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oscontext.Table, oscontext.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, oscontext.EventsTable, oscontext.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(oc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OSContextClient) Hooks() []Hook {
	return c.hooks.OSContext
}

// PageClient is a client for the Page schema.
type PageClient struct {
	config
}

// NewPageClient returns a client for the Page from the given config.
func NewPageClient(c config) *PageClient {
	return &PageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `page.Hooks(f(g(h())))`.
func (c *PageClient) Use(hooks ...Hook) {
	c.hooks.Page = append(c.hooks.Page, hooks...)
}

// Create returns a create builder for Page.
func (c *PageClient) Create() *PageCreate {
	mutation := newPageMutation(c.config, OpCreate)
	return &PageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Page entities.
func (c *PageClient) CreateBulk(builders ...*PageCreate) *PageCreateBulk {
	return &PageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Page.
func (c *PageClient) Update() *PageUpdate {
	mutation := newPageMutation(c.config, OpUpdate)
	return &PageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PageClient) UpdateOne(pa *Page) *PageUpdateOne {
	mutation := newPageMutation(c.config, OpUpdateOne, withPage(pa))
	return &PageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PageClient) UpdateOneID(id int) *PageUpdateOne {
	mutation := newPageMutation(c.config, OpUpdateOne, withPageID(id))
	return &PageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Page.
func (c *PageClient) Delete() *PageDelete {
	mutation := newPageMutation(c.config, OpDelete)
	return &PageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *PageClient) DeleteOne(pa *Page) *PageDeleteOne {
	return c.DeleteOneID(pa.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *PageClient) DeleteOneID(id int) *PageDeleteOne {
	builder := c.Delete().Where(page.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PageDeleteOne{builder}
}

// Query returns a query builder for Page.
func (c *PageClient) Query() *PageQuery {
	return &PageQuery{config: c.config}
}

// Get returns a Page entity by its id.
func (c *PageClient) Get(ctx context.Context, id int) (*Page, error) {
	return c.Query().Where(page.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PageClient) GetX(ctx context.Context, id int) *Page {
	pa, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return pa
}

// QueryEvents queries the events edge of a Page.
func (c *PageClient) QueryEvents(pa *Page) *EventQuery {
	query := &EventQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(page.Table, page.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, page.EventsTable, page.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PageClient) Hooks() []Hook {
	return c.hooks.Page
}

// ReferrerClient is a client for the Referrer schema.
type ReferrerClient struct {
	config
}

// NewReferrerClient returns a client for the Referrer from the given config.
func NewReferrerClient(c config) *ReferrerClient {
	return &ReferrerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `referrer.Hooks(f(g(h())))`.
func (c *ReferrerClient) Use(hooks ...Hook) {
	c.hooks.Referrer = append(c.hooks.Referrer, hooks...)
}

// Create returns a create builder for Referrer.
func (c *ReferrerClient) Create() *ReferrerCreate {
	mutation := newReferrerMutation(c.config, OpCreate)
	return &ReferrerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Referrer entities.
func (c *ReferrerClient) CreateBulk(builders ...*ReferrerCreate) *ReferrerCreateBulk {
	return &ReferrerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Referrer.
func (c *ReferrerClient) Update() *ReferrerUpdate {
	mutation := newReferrerMutation(c.config, OpUpdate)
	return &ReferrerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReferrerClient) UpdateOne(r *Referrer) *ReferrerUpdateOne {
	mutation := newReferrerMutation(c.config, OpUpdateOne, withReferrer(r))
	return &ReferrerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReferrerClient) UpdateOneID(id int) *ReferrerUpdateOne {
	mutation := newReferrerMutation(c.config, OpUpdateOne, withReferrerID(id))
	return &ReferrerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Referrer.
func (c *ReferrerClient) Delete() *ReferrerDelete {
	mutation := newReferrerMutation(c.config, OpDelete)
	return &ReferrerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ReferrerClient) DeleteOne(r *Referrer) *ReferrerDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ReferrerClient) DeleteOneID(id int) *ReferrerDeleteOne {
	builder := c.Delete().Where(referrer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReferrerDeleteOne{builder}
}

// Query returns a query builder for Referrer.
func (c *ReferrerClient) Query() *ReferrerQuery {
	return &ReferrerQuery{config: c.config}
}

// Get returns a Referrer entity by its id.
func (c *ReferrerClient) Get(ctx context.Context, id int) (*Referrer, error) {
	return c.Query().Where(referrer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReferrerClient) GetX(ctx context.Context, id int) *Referrer {
	r, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return r
}

// QueryEvents queries the events edge of a Referrer.
func (c *ReferrerClient) QueryEvents(r *Referrer) *EventQuery {
	query := &EventQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(referrer.Table, referrer.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, referrer.EventsTable, referrer.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReferrerClient) Hooks() []Hook {
	return c.hooks.Referrer
}

// ScreenClient is a client for the Screen schema.
type ScreenClient struct {
	config
}

// NewScreenClient returns a client for the Screen from the given config.
func NewScreenClient(c config) *ScreenClient {
	return &ScreenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `screen.Hooks(f(g(h())))`.
func (c *ScreenClient) Use(hooks ...Hook) {
	c.hooks.Screen = append(c.hooks.Screen, hooks...)
}

// Create returns a create builder for Screen.
func (c *ScreenClient) Create() *ScreenCreate {
	mutation := newScreenMutation(c.config, OpCreate)
	return &ScreenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Screen entities.
func (c *ScreenClient) CreateBulk(builders ...*ScreenCreate) *ScreenCreateBulk {
	return &ScreenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Screen.
func (c *ScreenClient) Update() *ScreenUpdate {
	mutation := newScreenMutation(c.config, OpUpdate)
	return &ScreenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScreenClient) UpdateOne(s *Screen) *ScreenUpdateOne {
	mutation := newScreenMutation(c.config, OpUpdateOne, withScreen(s))
	return &ScreenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScreenClient) UpdateOneID(id int) *ScreenUpdateOne {
	mutation := newScreenMutation(c.config, OpUpdateOne, withScreenID(id))
	return &ScreenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Screen.
func (c *ScreenClient) Delete() *ScreenDelete {
	mutation := newScreenMutation(c.config, OpDelete)
	return &ScreenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ScreenClient) DeleteOne(s *Screen) *ScreenDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ScreenClient) DeleteOneID(id int) *ScreenDeleteOne {
	builder := c.Delete().Where(screen.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScreenDeleteOne{builder}
}

// Query returns a query builder for Screen.
func (c *ScreenClient) Query() *ScreenQuery {
	return &ScreenQuery{config: c.config}
}

// Get returns a Screen entity by its id.
func (c *ScreenClient) Get(ctx context.Context, id int) (*Screen, error) {
	return c.Query().Where(screen.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScreenClient) GetX(ctx context.Context, id int) *Screen {
	s, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return s
}

// QueryEvents queries the events edge of a Screen.
func (c *ScreenClient) QueryEvents(s *Screen) *EventQuery {
	query := &EventQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(screen.Table, screen.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, screen.EventsTable, screen.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScreenClient) Hooks() []Hook {
	return c.hooks.Screen
}

// SessionClient is a client for the Session schema.
type SessionClient struct {
	config
}

// NewSessionClient returns a client for the Session from the given config.
func NewSessionClient(c config) *SessionClient {
	return &SessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `session.Hooks(f(g(h())))`.
func (c *SessionClient) Use(hooks ...Hook) {
	c.hooks.Session = append(c.hooks.Session, hooks...)
}

// Create returns a create builder for Session.
func (c *SessionClient) Create() *SessionCreate {
	mutation := newSessionMutation(c.config, OpCreate)
	return &SessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Session entities.
func (c *SessionClient) CreateBulk(builders ...*SessionCreate) *SessionCreateBulk {
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Session.
func (c *SessionClient) Update() *SessionUpdate {
	mutation := newSessionMutation(c.config, OpUpdate)
	return &SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SessionClient) UpdateOne(s *Session) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSession(s))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SessionClient) UpdateOneID(id uuid.UUID) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSessionID(id))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Session.
func (c *SessionClient) Delete() *SessionDelete {
	mutation := newSessionMutation(c.config, OpDelete)
	return &SessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *SessionClient) DeleteOne(s *Session) *SessionDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *SessionClient) DeleteOneID(id uuid.UUID) *SessionDeleteOne {
	builder := c.Delete().Where(session.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SessionDeleteOne{builder}
}

// Query returns a query builder for Session.
func (c *SessionClient) Query() *SessionQuery {
	return &SessionQuery{config: c.config}
}

// Get returns a Session entity by its id.
func (c *SessionClient) Get(ctx context.Context, id uuid.UUID) (*Session, error) {
	return c.Query().Where(session.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SessionClient) GetX(ctx context.Context, id uuid.UUID) *Session {
	s, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return s
}

// QueryEvents queries the events edge of a Session.
func (c *SessionClient) QueryEvents(s *Session) *EventQuery {
	query := &EventQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(session.Table, session.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, session.EventsTable, session.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SessionClient) Hooks() []Hook {
	return c.hooks.Session
}

// TimingClient is a client for the Timing schema.
type TimingClient struct {
	config
}

// NewTimingClient returns a client for the Timing from the given config.
func NewTimingClient(c config) *TimingClient {
	return &TimingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `timing.Hooks(f(g(h())))`.
func (c *TimingClient) Use(hooks ...Hook) {
	c.hooks.Timing = append(c.hooks.Timing, hooks...)
}

// Create returns a create builder for Timing.
func (c *TimingClient) Create() *TimingCreate {
	mutation := newTimingMutation(c.config, OpCreate)
	return &TimingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Timing entities.
func (c *TimingClient) CreateBulk(builders ...*TimingCreate) *TimingCreateBulk {
	return &TimingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Timing.
func (c *TimingClient) Update() *TimingUpdate {
	mutation := newTimingMutation(c.config, OpUpdate)
	return &TimingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TimingClient) UpdateOne(t *Timing) *TimingUpdateOne {
	mutation := newTimingMutation(c.config, OpUpdateOne, withTiming(t))
	return &TimingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TimingClient) UpdateOneID(id int) *TimingUpdateOne {
	mutation := newTimingMutation(c.config, OpUpdateOne, withTimingID(id))
	return &TimingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Timing.
func (c *TimingClient) Delete() *TimingDelete {
	mutation := newTimingMutation(c.config, OpDelete)
	return &TimingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *TimingClient) DeleteOne(t *Timing) *TimingDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *TimingClient) DeleteOneID(id int) *TimingDeleteOne {
	builder := c.Delete().Where(timing.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TimingDeleteOne{builder}
}

// Query returns a query builder for Timing.
func (c *TimingClient) Query() *TimingQuery {
	return &TimingQuery{config: c.config}
}

// Get returns a Timing entity by its id.
func (c *TimingClient) Get(ctx context.Context, id int) (*Timing, error) {
	return c.Query().Where(timing.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TimingClient) GetX(ctx context.Context, id int) *Timing {
	t, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return t
}

// QueryEvents queries the events edge of a Timing.
func (c *TimingClient) QueryEvents(t *Timing) *EventQuery {
	query := &EventQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(timing.Table, timing.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, timing.EventsTable, timing.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TimingClient) Hooks() []Hook {
	return c.hooks.Timing
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Create returns a create builder for User.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id string) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *UserClient) DeleteOneID(id string) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{config: c.config}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id string) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id string) *User {
	u, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return u
}

// QueryAliases queries the aliases edge of a User.
func (c *UserClient) QueryAliases(u *User) *AliasQuery {
	query := &AliasQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(alias.Table, alias.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AliasesTable, user.AliasesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a User.
func (c *UserClient) QueryEvents(u *User) *EventQuery {
	query := &EventQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.EventsTable, user.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroups queries the groups edge of a User.
func (c *UserClient) QueryGroups(u *User) *GroupQuery {
	query := &GroupQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, user.GroupsTable, user.GroupsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// ViewportClient is a client for the Viewport schema.
type ViewportClient struct {
	config
}

// NewViewportClient returns a client for the Viewport from the given config.
func NewViewportClient(c config) *ViewportClient {
	return &ViewportClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `viewport.Hooks(f(g(h())))`.
func (c *ViewportClient) Use(hooks ...Hook) {
	c.hooks.Viewport = append(c.hooks.Viewport, hooks...)
}

// Create returns a create builder for Viewport.
func (c *ViewportClient) Create() *ViewportCreate {
	mutation := newViewportMutation(c.config, OpCreate)
	return &ViewportCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Viewport entities.
func (c *ViewportClient) CreateBulk(builders ...*ViewportCreate) *ViewportCreateBulk {
	return &ViewportCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Viewport.
func (c *ViewportClient) Update() *ViewportUpdate {
	mutation := newViewportMutation(c.config, OpUpdate)
	return &ViewportUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ViewportClient) UpdateOne(v *Viewport) *ViewportUpdateOne {
	mutation := newViewportMutation(c.config, OpUpdateOne, withViewport(v))
	return &ViewportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ViewportClient) UpdateOneID(id int) *ViewportUpdateOne {
	mutation := newViewportMutation(c.config, OpUpdateOne, withViewportID(id))
	return &ViewportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Viewport.
func (c *ViewportClient) Delete() *ViewportDelete {
	mutation := newViewportMutation(c.config, OpDelete)
	return &ViewportDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ViewportClient) DeleteOne(v *Viewport) *ViewportDeleteOne {
	return c.DeleteOneID(v.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ViewportClient) DeleteOneID(id int) *ViewportDeleteOne {
	builder := c.Delete().Where(viewport.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ViewportDeleteOne{builder}
}

// Query returns a query builder for Viewport.
func (c *ViewportClient) Query() *ViewportQuery {
	return &ViewportQuery{config: c.config}
}

// Get returns a Viewport entity by its id.
func (c *ViewportClient) Get(ctx context.Context, id int) (*Viewport, error) {
	return c.Query().Where(viewport.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ViewportClient) GetX(ctx context.Context, id int) *Viewport {
	v, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return v
}

// QueryEvents queries the events edge of a Viewport.
func (c *ViewportClient) QueryEvents(v *Viewport) *EventQuery {
	query := &EventQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(viewport.Table, viewport.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, viewport.EventsTable, viewport.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ViewportClient) Hooks() []Hook {
	return c.hooks.Viewport
}
